/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/match/[id]/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiRDpcXGJpbmdvLWNwXFxiaW5nby1jcFxcYmluZ28tY3BcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcYXBpXFxuYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Csrc%5C%5Capp%5C%5Cmatch%5C%5C%5Bid%5D%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Csrc%5C%5Capp%5C%5Cmatch%5C%5C%5Bid%5D%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/match/[id]/page.tsx */ \"(app-pages-browser)/./src/app/match/[id]/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q2JpbmdvLWNwJTVDJTVDYmluZ28tY3AlNUMlNUNiaW5nby1jcCU1QyU1Q3NyYyU1QyU1Q2FwcCU1QyU1Q21hdGNoJTVDJTVDJTVCaWQlNUQlNUMlNUNwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLG9MQUFzRyIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcYmluZ28tY3BcXFxcYmluZ28tY3BcXFxcYmluZ28tY3BcXFxcc3JjXFxcXGFwcFxcXFxtYXRjaFxcXFxbaWRdXFxcXHBhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Csrc%5C%5Capp%5C%5Cmatch%5C%5C%5Bid%5D%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiRDpcXGJpbmdvLWNwXFxiaW5nby1jcFxcYmluZ28tY3BcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxjanNcXHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkQ6XFxiaW5nby1jcFxcYmluZ28tY3BcXGJpbmdvLWNwXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdFxcanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-confetti/dist/react-confetti.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/react-confetti/dist/react-confetti.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactConfetti)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var tween_functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tween-functions */ \"(app-pages-browser)/./node_modules/tween-functions/index.js\");\n\n\n\n\nfunction degreesToRads(degrees) {\n    return (degrees * Math.PI) / 180;\n}\nfunction randomRange(min, max) {\n    return min + Math.random() * (max - min);\n}\nfunction randomInt(min, max) {\n    return Math.floor(min + Math.random() * (max - min + 1));\n}\n\nvar ParticleShape;\n(function (ParticleShape) {\n    ParticleShape[ParticleShape[\"Circle\"] = 0] = \"Circle\";\n    ParticleShape[ParticleShape[\"Square\"] = 1] = \"Square\";\n    ParticleShape[ParticleShape[\"Strip\"] = 2] = \"Strip\";\n})(ParticleShape || (ParticleShape = {}));\nvar RotationDirection;\n(function (RotationDirection) {\n    RotationDirection[RotationDirection[\"Positive\"] = 1] = \"Positive\";\n    RotationDirection[RotationDirection[\"Negative\"] = -1] = \"Negative\";\n})(RotationDirection || (RotationDirection = {}));\nconst DEFAULT_FRAME_TIME = 1000 / 60;\nclass Particle {\n    constructor(context, getOptions, x, y) {\n        this.getOptions = getOptions;\n        const { colors, initialVelocityX, initialVelocityY } = this.getOptions();\n        this.context = context;\n        this.x = x;\n        this.y = y;\n        this.w = randomRange(5, 20);\n        this.h = randomRange(5, 20);\n        this.radius = randomRange(5, 10);\n        this.vx =\n            typeof initialVelocityX === 'number'\n                ? randomRange(-initialVelocityX, initialVelocityX)\n                : randomRange(initialVelocityX.min, initialVelocityX.max);\n        this.vy =\n            typeof initialVelocityY === 'number'\n                ? randomRange(-initialVelocityY, 0)\n                : randomRange(initialVelocityY.min, initialVelocityY.max);\n        this.shape = randomInt(0, 2);\n        this.angle = degreesToRads(randomRange(0, 360));\n        this.angularSpin = randomRange(-0.2, 0.2);\n        this.color = colors[Math.floor(Math.random() * colors.length)];\n        this.rotateY = randomRange(0, 1);\n        this.rotationDirection = randomRange(0, 1)\n            ? RotationDirection.Positive\n            : RotationDirection.Negative;\n    }\n    update(elapsed) {\n        const { gravity, wind, friction, opacity, drawShape } = this.getOptions();\n        const frameTimeMultiplier = elapsed / DEFAULT_FRAME_TIME;\n        this.x += this.vx * frameTimeMultiplier;\n        this.y += this.vy * frameTimeMultiplier;\n        this.vy += gravity * frameTimeMultiplier;\n        this.vx += wind * frameTimeMultiplier;\n        this.vx *= friction ** frameTimeMultiplier;\n        this.vy *= friction ** frameTimeMultiplier;\n        if (this.rotateY >= 1 &&\n            this.rotationDirection === RotationDirection.Positive) {\n            this.rotationDirection = RotationDirection.Negative;\n        }\n        else if (this.rotateY <= -1 &&\n            this.rotationDirection === RotationDirection.Negative) {\n            this.rotationDirection = RotationDirection.Positive;\n        }\n        const rotateDelta = 0.1 * this.rotationDirection * frameTimeMultiplier;\n        this.rotateY += rotateDelta;\n        this.angle += this.angularSpin;\n        this.context.save();\n        this.context.translate(this.x, this.y);\n        this.context.rotate(this.angle);\n        this.context.scale(1, this.rotateY);\n        this.context.rotate(this.angle);\n        this.context.beginPath();\n        this.context.fillStyle = this.color;\n        this.context.strokeStyle = this.color;\n        this.context.globalAlpha = opacity;\n        this.context.lineCap = 'round';\n        this.context.lineWidth = 2;\n        if (drawShape && typeof drawShape === 'function') {\n            drawShape.call(this, this.context);\n        }\n        else {\n            switch (this.shape) {\n                case ParticleShape.Circle: {\n                    this.context.beginPath();\n                    this.context.arc(0, 0, this.radius, 0, 2 * Math.PI);\n                    this.context.fill();\n                    break;\n                }\n                case ParticleShape.Square: {\n                    this.context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);\n                    break;\n                }\n                case ParticleShape.Strip: {\n                    this.context.fillRect(-this.w / 6, -this.h / 2, this.w / 3, this.h);\n                    break;\n                }\n            }\n        }\n        this.context.closePath();\n        this.context.restore();\n    }\n}\n\nclass ParticleGenerator {\n    constructor(canvas, getOptions) {\n        this.x = 0;\n        this.y = 0;\n        this.w = 0;\n        this.h = 0;\n        this.lastNumberOfPieces = 0;\n        this.tweenProgress = 0;\n        this.tweenFrom = 0;\n        this.particles = [];\n        this.particlesGenerated = 0;\n        this.removeParticleAt = (i) => {\n            this.particles.splice(i, 1);\n        };\n        this.getParticle = () => {\n            const newParticleX = randomRange(this.x, this.w + this.x);\n            const newParticleY = randomRange(this.y, this.h + this.y);\n            return new Particle(this.context, this.getOptions, newParticleX, newParticleY);\n        };\n        this.animate = (elapsed) => {\n            const { canvas, context, particlesGenerated, lastNumberOfPieces } = this;\n            const { run, recycle, numberOfPieces, debug, tweenFunction, tweenDuration, } = this.getOptions();\n            if (!run) {\n                return false;\n            }\n            const nP = this.particles.length;\n            const activeCount = recycle ? nP : particlesGenerated;\n            // Initial population\n            if (activeCount < numberOfPieces) {\n                // Use the numberOfPieces prop as a key to reset the easing timing\n                if (lastNumberOfPieces !== numberOfPieces) {\n                    this.tweenProgress = 0;\n                    this.tweenFrom = activeCount;\n                    this.lastNumberOfPieces = numberOfPieces;\n                }\n                // Clamp tweenProgress between 0 and tweenDuration\n                this.tweenProgress = Math.min(tweenDuration, Math.max(0, this.tweenProgress + elapsed));\n                const tweenedVal = tweenFunction(this.tweenProgress, this.tweenFrom, numberOfPieces, tweenDuration);\n                const numToAdd = Math.round(tweenedVal - activeCount);\n                for (let i = 0; i < numToAdd; i++) {\n                    this.particles.push(this.getParticle());\n                }\n                this.particlesGenerated += numToAdd;\n            }\n            if (debug) {\n                // Draw debug text\n                context.font = '12px sans-serif';\n                context.fillStyle = '#333';\n                context.textAlign = 'right';\n                context.fillText(`Particles: ${nP}`, canvas.width - 10, canvas.height - 20);\n            }\n            // Maintain the population, iterating backwards to prevent issues when removing particles\n            for (let i = this.particles.length - 1; i >= 0; i--) {\n                const p = this.particles[i];\n                // Update each particle's position\n                p.update(elapsed);\n                // Prune the off-canvas particles\n                if (p.y > canvas.height ||\n                    p.y < -100 ||\n                    p.x > canvas.width + 100 ||\n                    p.x < -100) {\n                    if (recycle && activeCount <= numberOfPieces) {\n                        // Replace the particle with a brand new one\n                        this.particles[i] = this.getParticle();\n                    }\n                    else {\n                        this.removeParticleAt(i);\n                    }\n                }\n            }\n            return nP > 0 || activeCount < numberOfPieces;\n        };\n        this.canvas = canvas;\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Could not get canvas context');\n        }\n        this.context = ctx;\n        this.getOptions = getOptions;\n    }\n}\n\nconst confettiDefaults = {\n    width: typeof window !== 'undefined' ? window.innerWidth : 300,\n    height: typeof window !== 'undefined' ? window.innerHeight : 200,\n    numberOfPieces: 200,\n    friction: 0.99,\n    wind: 0,\n    gravity: 0.1,\n    initialVelocityX: 4,\n    initialVelocityY: 10,\n    colors: [\n        '#f44336',\n        '#e91e63',\n        '#9c27b0',\n        '#673ab7',\n        '#3f51b5',\n        '#2196f3',\n        '#03a9f4',\n        '#00bcd4',\n        '#009688',\n        '#4CAF50',\n        '#8BC34A',\n        '#CDDC39',\n        '#FFEB3B',\n        '#FFC107',\n        '#FF9800',\n        '#FF5722',\n        '#795548',\n    ],\n    opacity: 1.0,\n    debug: false,\n    tweenFunction: tween_functions__WEBPACK_IMPORTED_MODULE_2__.easeInOutQuad,\n    tweenDuration: 5000,\n    recycle: true,\n    run: true,\n};\nclass Confetti {\n    constructor(canvas, opts) {\n        this.lastFrameTime = 0;\n        this.setOptionsWithDefaults = (opts) => {\n            const computedConfettiDefaults = {\n                confettiSource: {\n                    x: 0,\n                    y: 0,\n                    w: this.canvas.width,\n                    h: 0,\n                },\n            };\n            this._options = {\n                ...computedConfettiDefaults,\n                ...confettiDefaults,\n                ...opts,\n            };\n            Object.assign(this, opts.confettiSource);\n        };\n        this.update = (timestamp = 0) => {\n            const { options: { run, onConfettiComplete, frameRate }, canvas, context, } = this;\n            // Cap elapsed time to 50ms to prevent large time steps\n            const elapsed = Math.min(timestamp - this.lastFrameTime, 50);\n            // Throttle the frame rate if set\n            if (frameRate && elapsed < 1000 / frameRate) {\n                this.rafId = requestAnimationFrame(this.update);\n                return;\n            }\n            this.lastFrameTime = timestamp - (frameRate ? elapsed % frameRate : 0);\n            if (run) {\n                context.fillStyle = 'white';\n                context.clearRect(0, 0, canvas.width, canvas.height);\n            }\n            if (this.generator.animate(elapsed)) {\n                this.rafId = requestAnimationFrame(this.update);\n            }\n            else {\n                if (onConfettiComplete &&\n                    typeof onConfettiComplete === 'function' &&\n                    this.generator.particlesGenerated > 0) {\n                    onConfettiComplete.call(this, this);\n                }\n                this._options.run = false;\n            }\n        };\n        this.reset = () => {\n            if (this.generator && this.generator.particlesGenerated > 0) {\n                this.generator.particlesGenerated = 0;\n                this.generator.particles = [];\n                this.generator.lastNumberOfPieces = 0;\n            }\n        };\n        this.stop = () => {\n            this.options = { run: false };\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n                this.rafId = undefined;\n            }\n        };\n        this.canvas = canvas;\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Could not get canvas context');\n        }\n        this.context = ctx;\n        this.generator = new ParticleGenerator(this.canvas, () => this.options);\n        this.options = opts;\n        this.update();\n    }\n    get options() {\n        return this._options;\n    }\n    set options(opts) {\n        const lastRunState = this._options?.run;\n        const lastRecycleState = this._options?.recycle;\n        this.setOptionsWithDefaults(opts);\n        if (this.generator) {\n            Object.assign(this.generator, this.options.confettiSource);\n            if (typeof opts.recycle === 'boolean' &&\n                opts.recycle &&\n                lastRecycleState === false) {\n                this.generator.lastNumberOfPieces = this.generator.particles.length;\n            }\n        }\n        if (typeof opts.run === 'boolean' && opts.run && lastRunState === false) {\n            this.update();\n        }\n    }\n}\n\nconst ref = react__WEBPACK_IMPORTED_MODULE_1__.createRef();\nclass ReactConfettiInternal extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        this.canvas = react__WEBPACK_IMPORTED_MODULE_1__.createRef();\n        this.canvas = props.canvasRef || ref;\n    }\n    componentDidMount() {\n        if (this.canvas.current) {\n            const opts = extractCanvasProps(this.props)[0];\n            this.confetti = new Confetti(this.canvas.current, opts);\n        }\n    }\n    componentDidUpdate() {\n        const confettiOptions = extractCanvasProps(this.props)[0];\n        if (this.confetti) {\n            this.confetti.options = confettiOptions;\n        }\n    }\n    componentWillUnmount() {\n        if (this.confetti) {\n            this.confetti.stop();\n        }\n        this.confetti = undefined;\n    }\n    render() {\n        const [confettiOptions, passedProps] = extractCanvasProps(this.props);\n        const canvasStyles = {\n            zIndex: 2,\n            position: 'absolute',\n            pointerEvents: 'none',\n            top: 0,\n            left: 0,\n            bottom: 0,\n            right: 0,\n            ...passedProps.style,\n        };\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"canvas\", { width: confettiOptions.width, height: confettiOptions.height, ref: this.canvas, ...passedProps, style: canvasStyles }));\n    }\n}\nReactConfettiInternal.defaultProps = {\n    ...confettiDefaults,\n};\nReactConfettiInternal.displayName = 'ReactConfetti';\nfunction extractCanvasProps(props) {\n    const confettiOptions = {};\n    const refs = {};\n    const rest = {};\n    const confettiOptionKeys = [\n        ...Object.keys(confettiDefaults),\n        'confettiSource',\n        'drawShape',\n        'onConfettiComplete',\n        'frameRate',\n    ];\n    const refProps = ['canvasRef'];\n    for (const prop in props) {\n        const val = props[prop];\n        if (confettiOptionKeys.includes(prop)) {\n            confettiOptions[prop] = val;\n        }\n        else if (refProps.includes(prop)) {\n            refProps[prop] = val;\n        }\n        else {\n            rest[prop] = val;\n        }\n    }\n    return [confettiOptions, rest, refs];\n}\nconst ReactConfetti = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactConfettiInternal, { canvasRef: ref, ...props }));\n\n\n//# sourceMappingURL=react-confetti.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jb25mZXR0aS9kaXN0L3JlYWN0LWNvbmZldHRpLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ2Q7QUFDZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUE4QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBMEQ7QUFDOUUsb0JBQW9CLHFFQUFxRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxvQ0FBb0MscUJBQXFCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDRDQUFlO0FBQzNCLG9DQUFvQyw0Q0FBZTtBQUNuRDtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQUcsYUFBYSxxSEFBcUg7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBZ0IsaUJBQWlCLHNEQUFHLDBCQUEwQiwwQkFBMEI7O0FBRTFFO0FBQ3BDIiwic291cmNlcyI6WyJEOlxcYmluZ28tY3BcXGJpbmdvLWNwXFxiaW5nby1jcFxcbm9kZV9tb2R1bGVzXFxyZWFjdC1jb25mZXR0aVxcZGlzdFxccmVhY3QtY29uZmV0dGkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyB0d2VlbnMgZnJvbSAndHdlZW4tZnVuY3Rpb25zJztcblxuZnVuY3Rpb24gZGVncmVlc1RvUmFkcyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIChkZWdyZWVzICogTWF0aC5QSSkgLyAxODA7XG59XG5mdW5jdGlvbiByYW5kb21SYW5nZShtaW4sIG1heCkge1xuICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG59XG5mdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbn1cblxudmFyIFBhcnRpY2xlU2hhcGU7XG4oZnVuY3Rpb24gKFBhcnRpY2xlU2hhcGUpIHtcbiAgICBQYXJ0aWNsZVNoYXBlW1BhcnRpY2xlU2hhcGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XG4gICAgUGFydGljbGVTaGFwZVtQYXJ0aWNsZVNoYXBlW1wiU3F1YXJlXCJdID0gMV0gPSBcIlNxdWFyZVwiO1xuICAgIFBhcnRpY2xlU2hhcGVbUGFydGljbGVTaGFwZVtcIlN0cmlwXCJdID0gMl0gPSBcIlN0cmlwXCI7XG59KShQYXJ0aWNsZVNoYXBlIHx8IChQYXJ0aWNsZVNoYXBlID0ge30pKTtcbnZhciBSb3RhdGlvbkRpcmVjdGlvbjtcbihmdW5jdGlvbiAoUm90YXRpb25EaXJlY3Rpb24pIHtcbiAgICBSb3RhdGlvbkRpcmVjdGlvbltSb3RhdGlvbkRpcmVjdGlvbltcIlBvc2l0aXZlXCJdID0gMV0gPSBcIlBvc2l0aXZlXCI7XG4gICAgUm90YXRpb25EaXJlY3Rpb25bUm90YXRpb25EaXJlY3Rpb25bXCJOZWdhdGl2ZVwiXSA9IC0xXSA9IFwiTmVnYXRpdmVcIjtcbn0pKFJvdGF0aW9uRGlyZWN0aW9uIHx8IChSb3RhdGlvbkRpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBERUZBVUxUX0ZSQU1FX1RJTUUgPSAxMDAwIC8gNjA7XG5jbGFzcyBQYXJ0aWNsZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZ2V0T3B0aW9ucywgeCwgeSkge1xuICAgICAgICB0aGlzLmdldE9wdGlvbnMgPSBnZXRPcHRpb25zO1xuICAgICAgICBjb25zdCB7IGNvbG9ycywgaW5pdGlhbFZlbG9jaXR5WCwgaW5pdGlhbFZlbG9jaXR5WSB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMudyA9IHJhbmRvbVJhbmdlKDUsIDIwKTtcbiAgICAgICAgdGhpcy5oID0gcmFuZG9tUmFuZ2UoNSwgMjApO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhbmRvbVJhbmdlKDUsIDEwKTtcbiAgICAgICAgdGhpcy52eCA9XG4gICAgICAgICAgICB0eXBlb2YgaW5pdGlhbFZlbG9jaXR5WCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IHJhbmRvbVJhbmdlKC1pbml0aWFsVmVsb2NpdHlYLCBpbml0aWFsVmVsb2NpdHlYKVxuICAgICAgICAgICAgICAgIDogcmFuZG9tUmFuZ2UoaW5pdGlhbFZlbG9jaXR5WC5taW4sIGluaXRpYWxWZWxvY2l0eVgubWF4KTtcbiAgICAgICAgdGhpcy52eSA9XG4gICAgICAgICAgICB0eXBlb2YgaW5pdGlhbFZlbG9jaXR5WSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IHJhbmRvbVJhbmdlKC1pbml0aWFsVmVsb2NpdHlZLCAwKVxuICAgICAgICAgICAgICAgIDogcmFuZG9tUmFuZ2UoaW5pdGlhbFZlbG9jaXR5WS5taW4sIGluaXRpYWxWZWxvY2l0eVkubWF4KTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHJhbmRvbUludCgwLCAyKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGRlZ3JlZXNUb1JhZHMocmFuZG9tUmFuZ2UoMCwgMzYwKSk7XG4gICAgICAgIHRoaXMuYW5ndWxhclNwaW4gPSByYW5kb21SYW5nZSgtMC4yLCAwLjIpO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbiAgICAgICAgdGhpcy5yb3RhdGVZID0gcmFuZG9tUmFuZ2UoMCwgMSk7XG4gICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24gPSByYW5kb21SYW5nZSgwLCAxKVxuICAgICAgICAgICAgPyBSb3RhdGlvbkRpcmVjdGlvbi5Qb3NpdGl2ZVxuICAgICAgICAgICAgOiBSb3RhdGlvbkRpcmVjdGlvbi5OZWdhdGl2ZTtcbiAgICB9XG4gICAgdXBkYXRlKGVsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgeyBncmF2aXR5LCB3aW5kLCBmcmljdGlvbiwgb3BhY2l0eSwgZHJhd1NoYXBlIH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZnJhbWVUaW1lTXVsdGlwbGllciA9IGVsYXBzZWQgLyBERUZBVUxUX0ZSQU1FX1RJTUU7XG4gICAgICAgIHRoaXMueCArPSB0aGlzLnZ4ICogZnJhbWVUaW1lTXVsdGlwbGllcjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMudnkgKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnZ5ICs9IGdyYXZpdHkgKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnZ4ICs9IHdpbmQgKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnZ4ICo9IGZyaWN0aW9uICoqIGZyYW1lVGltZU11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMudnkgKj0gZnJpY3Rpb24gKiogZnJhbWVUaW1lTXVsdGlwbGllcjtcbiAgICAgICAgaWYgKHRoaXMucm90YXRlWSA+PSAxICYmXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID09PSBSb3RhdGlvbkRpcmVjdGlvbi5Qb3NpdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9IFJvdGF0aW9uRGlyZWN0aW9uLk5lZ2F0aXZlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucm90YXRlWSA8PSAtMSAmJlxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9PT0gUm90YXRpb25EaXJlY3Rpb24uTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24gPSBSb3RhdGlvbkRpcmVjdGlvbi5Qb3NpdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3RhdGVEZWx0YSA9IDAuMSAqIHRoaXMucm90YXRpb25EaXJlY3Rpb24gKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgKz0gcm90YXRlRGVsdGE7XG4gICAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy5hbmd1bGFyU3BpbjtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5zY2FsZSgxLCB0aGlzLnJvdGF0ZVkpO1xuICAgICAgICB0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICB0aGlzLmNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSAyO1xuICAgICAgICBpZiAoZHJhd1NoYXBlICYmIHR5cGVvZiBkcmF3U2hhcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRyYXdTaGFwZS5jYWxsKHRoaXMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFBhcnRpY2xlU2hhcGUuQ2lyY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFyYygwLCAwLCB0aGlzLnJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBQYXJ0aWNsZVNoYXBlLlNxdWFyZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoLXRoaXMudyAvIDIsIC10aGlzLmggLyAyLCB0aGlzLncsIHRoaXMuaCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFBhcnRpY2xlU2hhcGUuU3RyaXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KC10aGlzLncgLyA2LCAtdGhpcy5oIC8gMiwgdGhpcy53IC8gMywgdGhpcy5oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG59XG5cbmNsYXNzIFBhcnRpY2xlR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIGdldE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgdGhpcy5oID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TnVtYmVyT2ZQaWVjZXMgPSAwO1xuICAgICAgICB0aGlzLnR3ZWVuUHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0aGlzLnR3ZWVuRnJvbSA9IDA7XG4gICAgICAgIHRoaXMucGFydGljbGVzID0gW107XG4gICAgICAgIHRoaXMucGFydGljbGVzR2VuZXJhdGVkID0gMDtcbiAgICAgICAgdGhpcy5yZW1vdmVQYXJ0aWNsZUF0ID0gKGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRQYXJ0aWNsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcnRpY2xlWCA9IHJhbmRvbVJhbmdlKHRoaXMueCwgdGhpcy53ICsgdGhpcy54KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcnRpY2xlWSA9IHJhbmRvbVJhbmdlKHRoaXMueSwgdGhpcy5oICsgdGhpcy55KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFydGljbGUodGhpcy5jb250ZXh0LCB0aGlzLmdldE9wdGlvbnMsIG5ld1BhcnRpY2xlWCwgbmV3UGFydGljbGVZKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gKGVsYXBzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0LCBwYXJ0aWNsZXNHZW5lcmF0ZWQsIGxhc3ROdW1iZXJPZlBpZWNlcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcnVuLCByZWN5Y2xlLCBudW1iZXJPZlBpZWNlcywgZGVidWcsIHR3ZWVuRnVuY3Rpb24sIHR3ZWVuRHVyYXRpb24sIH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblAgPSB0aGlzLnBhcnRpY2xlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVDb3VudCA9IHJlY3ljbGUgPyBuUCA6IHBhcnRpY2xlc0dlbmVyYXRlZDtcbiAgICAgICAgICAgIC8vIEluaXRpYWwgcG9wdWxhdGlvblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUNvdW50IDwgbnVtYmVyT2ZQaWVjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG51bWJlck9mUGllY2VzIHByb3AgYXMgYSBrZXkgdG8gcmVzZXQgdGhlIGVhc2luZyB0aW1pbmdcbiAgICAgICAgICAgICAgICBpZiAobGFzdE51bWJlck9mUGllY2VzICE9PSBudW1iZXJPZlBpZWNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWVuUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWVuRnJvbSA9IGFjdGl2ZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3ROdW1iZXJPZlBpZWNlcyA9IG51bWJlck9mUGllY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbGFtcCB0d2VlblByb2dyZXNzIGJldHdlZW4gMCBhbmQgdHdlZW5EdXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5Qcm9ncmVzcyA9IE1hdGgubWluKHR3ZWVuRHVyYXRpb24sIE1hdGgubWF4KDAsIHRoaXMudHdlZW5Qcm9ncmVzcyArIGVsYXBzZWQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0d2VlbmVkVmFsID0gdHdlZW5GdW5jdGlvbih0aGlzLnR3ZWVuUHJvZ3Jlc3MsIHRoaXMudHdlZW5Gcm9tLCBudW1iZXJPZlBpZWNlcywgdHdlZW5EdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtVG9BZGQgPSBNYXRoLnJvdW5kKHR3ZWVuZWRWYWwgLSBhY3RpdmVDb3VudCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ub0FkZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnB1c2godGhpcy5nZXRQYXJ0aWNsZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXNHZW5lcmF0ZWQgKz0gbnVtVG9BZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGRlYnVnIHRleHRcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZvbnQgPSAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMzMzJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChgUGFydGljbGVzOiAke25QfWAsIGNhbnZhcy53aWR0aCAtIDEwLCBjYW52YXMuaGVpZ2h0IC0gMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFpbnRhaW4gdGhlIHBvcHVsYXRpb24sIGl0ZXJhdGluZyBiYWNrd2FyZHMgdG8gcHJldmVudCBpc3N1ZXMgd2hlbiByZW1vdmluZyBwYXJ0aWNsZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhcnRpY2xlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZWFjaCBwYXJ0aWNsZSdzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcC51cGRhdGUoZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgLy8gUHJ1bmUgdGhlIG9mZi1jYW52YXMgcGFydGljbGVzXG4gICAgICAgICAgICAgICAgaWYgKHAueSA+IGNhbnZhcy5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgcC55IDwgLTEwMCB8fFxuICAgICAgICAgICAgICAgICAgICBwLnggPiBjYW52YXMud2lkdGggKyAxMDAgfHxcbiAgICAgICAgICAgICAgICAgICAgcC54IDwgLTEwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjeWNsZSAmJiBhY3RpdmVDb3VudCA8PSBudW1iZXJPZlBpZWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcGFydGljbGUgd2l0aCBhIGJyYW5kIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzW2ldID0gdGhpcy5nZXRQYXJ0aWNsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0aWNsZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5QID4gMCB8fCBhY3RpdmVDb3VudCA8IG51bWJlck9mUGllY2VzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGN0eDtcbiAgICAgICAgdGhpcy5nZXRPcHRpb25zID0gZ2V0T3B0aW9ucztcbiAgICB9XG59XG5cbmNvbnN0IGNvbmZldHRpRGVmYXVsdHMgPSB7XG4gICAgd2lkdGg6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVyV2lkdGggOiAzMDAsXG4gICAgaGVpZ2h0OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IDIwMCxcbiAgICBudW1iZXJPZlBpZWNlczogMjAwLFxuICAgIGZyaWN0aW9uOiAwLjk5LFxuICAgIHdpbmQ6IDAsXG4gICAgZ3Jhdml0eTogMC4xLFxuICAgIGluaXRpYWxWZWxvY2l0eVg6IDQsXG4gICAgaW5pdGlhbFZlbG9jaXR5WTogMTAsXG4gICAgY29sb3JzOiBbXG4gICAgICAgICcjZjQ0MzM2JyxcbiAgICAgICAgJyNlOTFlNjMnLFxuICAgICAgICAnIzljMjdiMCcsXG4gICAgICAgICcjNjczYWI3JyxcbiAgICAgICAgJyMzZjUxYjUnLFxuICAgICAgICAnIzIxOTZmMycsXG4gICAgICAgICcjMDNhOWY0JyxcbiAgICAgICAgJyMwMGJjZDQnLFxuICAgICAgICAnIzAwOTY4OCcsXG4gICAgICAgICcjNENBRjUwJyxcbiAgICAgICAgJyM4QkMzNEEnLFxuICAgICAgICAnI0NEREMzOScsXG4gICAgICAgICcjRkZFQjNCJyxcbiAgICAgICAgJyNGRkMxMDcnLFxuICAgICAgICAnI0ZGOTgwMCcsXG4gICAgICAgICcjRkY1NzIyJyxcbiAgICAgICAgJyM3OTU1NDgnLFxuICAgIF0sXG4gICAgb3BhY2l0eTogMS4wLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICB0d2VlbkZ1bmN0aW9uOiB0d2VlbnMuZWFzZUluT3V0UXVhZCxcbiAgICB0d2VlbkR1cmF0aW9uOiA1MDAwLFxuICAgIHJlY3ljbGU6IHRydWUsXG4gICAgcnVuOiB0cnVlLFxufTtcbmNsYXNzIENvbmZldHRpIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zV2l0aERlZmF1bHRzID0gKG9wdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkQ29uZmV0dGlEZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBjb25mZXR0aVNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3OiB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uY29tcHV0ZWRDb25mZXR0aURlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZldHRpRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdHMuY29uZmV0dGlTb3VyY2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSA9ICh0aW1lc3RhbXAgPSAwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnM6IHsgcnVuLCBvbkNvbmZldHRpQ29tcGxldGUsIGZyYW1lUmF0ZSB9LCBjYW52YXMsIGNvbnRleHQsIH0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gQ2FwIGVsYXBzZWQgdGltZSB0byA1MG1zIHRvIHByZXZlbnQgbGFyZ2UgdGltZSBzdGVwc1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IE1hdGgubWluKHRpbWVzdGFtcCAtIHRoaXMubGFzdEZyYW1lVGltZSwgNTApO1xuICAgICAgICAgICAgLy8gVGhyb3R0bGUgdGhlIGZyYW1lIHJhdGUgaWYgc2V0XG4gICAgICAgICAgICBpZiAoZnJhbWVSYXRlICYmIGVsYXBzZWQgPCAxMDAwIC8gZnJhbWVSYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wIC0gKGZyYW1lUmF0ZSA/IGVsYXBzZWQgJSBmcmFtZVJhdGUgOiAwKTtcbiAgICAgICAgICAgIGlmIChydW4pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdlbmVyYXRvci5hbmltYXRlKGVsYXBzZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob25Db25mZXR0aUNvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvbkNvbmZldHRpQ29tcGxldGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IucGFydGljbGVzR2VuZXJhdGVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNvbmZldHRpQ29tcGxldGUuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5ydW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdlbmVyYXRvciAmJiB0aGlzLmdlbmVyYXRvci5wYXJ0aWNsZXNHZW5lcmF0ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IucGFydGljbGVzR2VuZXJhdGVkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5sYXN0TnVtYmVyT2ZQaWVjZXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IHJ1bjogZmFsc2UgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZklkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWZJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjdHg7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gbmV3IFBhcnRpY2xlR2VuZXJhdG9yKHRoaXMuY2FudmFzLCAoKSA9PiB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIHNldCBvcHRpb25zKG9wdHMpIHtcbiAgICAgICAgY29uc3QgbGFzdFJ1blN0YXRlID0gdGhpcy5fb3B0aW9ucz8ucnVuO1xuICAgICAgICBjb25zdCBsYXN0UmVjeWNsZVN0YXRlID0gdGhpcy5fb3B0aW9ucz8ucmVjeWNsZTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zV2l0aERlZmF1bHRzKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5nZW5lcmF0b3IsIHRoaXMub3B0aW9ucy5jb25mZXR0aVNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMucmVjeWNsZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICAgICAgb3B0cy5yZWN5Y2xlICYmXG4gICAgICAgICAgICAgICAgbGFzdFJlY3ljbGVTdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5sYXN0TnVtYmVyT2ZQaWVjZXMgPSB0aGlzLmdlbmVyYXRvci5wYXJ0aWNsZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5ydW4gPT09ICdib29sZWFuJyAmJiBvcHRzLnJ1biAmJiBsYXN0UnVuU3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCByZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbmNsYXNzIFJlYWN0Q29uZmV0dGlJbnRlcm5hbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHByb3BzLmNhbnZhc1JlZiB8fCByZWY7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGV4dHJhY3RDYW52YXNQcm9wcyh0aGlzLnByb3BzKVswXTtcbiAgICAgICAgICAgIHRoaXMuY29uZmV0dGkgPSBuZXcgQ29uZmV0dGkodGhpcy5jYW52YXMuY3VycmVudCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCBjb25mZXR0aU9wdGlvbnMgPSBleHRyYWN0Q2FudmFzUHJvcHModGhpcy5wcm9wcylbMF07XG4gICAgICAgIGlmICh0aGlzLmNvbmZldHRpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZldHRpLm9wdGlvbnMgPSBjb25mZXR0aU9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZldHRpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZldHRpLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZldHRpID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IFtjb25mZXR0aU9wdGlvbnMsIHBhc3NlZFByb3BzXSA9IGV4dHJhY3RDYW52YXNQcm9wcyh0aGlzLnByb3BzKTtcbiAgICAgICAgY29uc3QgY2FudmFzU3R5bGVzID0ge1xuICAgICAgICAgICAgekluZGV4OiAyLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAuLi5wYXNzZWRQcm9wcy5zdHlsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChqc3goXCJjYW52YXNcIiwgeyB3aWR0aDogY29uZmV0dGlPcHRpb25zLndpZHRoLCBoZWlnaHQ6IGNvbmZldHRpT3B0aW9ucy5oZWlnaHQsIHJlZjogdGhpcy5jYW52YXMsIC4uLnBhc3NlZFByb3BzLCBzdHlsZTogY2FudmFzU3R5bGVzIH0pKTtcbiAgICB9XG59XG5SZWFjdENvbmZldHRpSW50ZXJuYWwuZGVmYXVsdFByb3BzID0ge1xuICAgIC4uLmNvbmZldHRpRGVmYXVsdHMsXG59O1xuUmVhY3RDb25mZXR0aUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1JlYWN0Q29uZmV0dGknO1xuZnVuY3Rpb24gZXh0cmFjdENhbnZhc1Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgY29uZmV0dGlPcHRpb25zID0ge307XG4gICAgY29uc3QgcmVmcyA9IHt9O1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBjb25zdCBjb25mZXR0aU9wdGlvbktleXMgPSBbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKGNvbmZldHRpRGVmYXVsdHMpLFxuICAgICAgICAnY29uZmV0dGlTb3VyY2UnLFxuICAgICAgICAnZHJhd1NoYXBlJyxcbiAgICAgICAgJ29uQ29uZmV0dGlDb21wbGV0ZScsXG4gICAgICAgICdmcmFtZVJhdGUnLFxuICAgIF07XG4gICAgY29uc3QgcmVmUHJvcHMgPSBbJ2NhbnZhc1JlZiddO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCB2YWwgPSBwcm9wc1twcm9wXTtcbiAgICAgICAgaWYgKGNvbmZldHRpT3B0aW9uS2V5cy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgY29uZmV0dGlPcHRpb25zW3Byb3BdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZlByb3BzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICByZWZQcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3RbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjb25mZXR0aU9wdGlvbnMsIHJlc3QsIHJlZnNdO1xufVxuY29uc3QgUmVhY3RDb25mZXR0aSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGpzeChSZWFjdENvbmZldHRpSW50ZXJuYWwsIHsgY2FudmFzUmVmOiByZWYsIC4uLnByb3BzIH0pKTtcblxuZXhwb3J0IHsgUmVhY3RDb25mZXR0aSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1jb25mZXR0aS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-confetti/dist/react-confetti.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tween-functions/index.js":
/*!***********************************************!*\
  !*** ./node_modules/tween-functions/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\n// t: current time, b: beginning value, _c: final value, d: total duration\nvar tweenFunctions = {\n  linear: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * t / d + b;\n  },\n  easeInQuad: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * (t /= d) * t + b;\n  },\n  easeOutQuad: function(t, b, _c, d) {\n    var c = _c - b;\n    return -c * (t /= d) * (t - 2) + b;\n  },\n  easeInOutQuad: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t + b;\n    } else {\n      return -c / 2 * ((--t) * (t - 2) - 1) + b;\n    }\n  },\n  easeInCubic: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * (t /= d) * t * t + b;\n  },\n  easeOutCubic: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n  },\n  easeInOutCubic: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n  },\n  easeInQuart: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * (t /= d) * t * t * t + b;\n  },\n  easeOutQuart: function(t, b, _c, d) {\n    var c = _c - b;\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n  },\n  easeInOutQuart: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t * t + b;\n    } else {\n      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n  },\n  easeInQuint: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * (t /= d) * t * t * t * t + b;\n  },\n  easeOutQuint: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n  },\n  easeInOutQuint: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t * t * t + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n  },\n  easeInSine: function(t, b, _c, d) {\n    var c = _c - b;\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n  },\n  easeOutSine: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n  },\n  easeInOutSine: function(t, b, _c, d) {\n    var c = _c - b;\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n  },\n  easeInExpo: function(t, b, _c, d) {\n    var c = _c - b;\n    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n  },\n  easeOutExpo: function(t, b, _c, d) {\n    var c = _c - b;\n    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n  },\n  easeInOutExpo: function(t, b, _c, d) {\n    var c = _c - b;\n    if (t === 0) {\n      return b;\n    }\n    if (t === d) {\n      return b + c;\n    }\n    if ((t /= d / 2) < 1) {\n      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    } else {\n      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n  },\n  easeInCirc: function(t, b, _c, d) {\n    var c = _c - b;\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n  },\n  easeOutCirc: function(t, b, _c, d) {\n    var c = _c - b;\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n  },\n  easeInOutCirc: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    } else {\n      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n  },\n  easeInElastic: function(t, b, _c, d) {\n    var c = _c - b;\n    var a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d) === 1) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * 0.3;\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n  },\n  easeOutElastic: function(t, b, _c, d) {\n    var c = _c - b;\n    var a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d) === 1) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * 0.3;\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n  },\n  easeInOutElastic: function(t, b, _c, d) {\n    var c = _c - b;\n    var a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d / 2) === 2) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * (0.3 * 1.5);\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    } else {\n      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;\n    }\n  },\n  easeInBack: function(t, b, _c, d, s) {\n    var c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n  },\n  easeOutBack: function(t, b, _c, d, s) {\n    var c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n  },\n  easeInOutBack: function(t, b, _c, d, s) {\n    var c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    if ((t /= d / 2) < 1) {\n      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n  },\n  easeInBounce: function(t, b, _c, d) {\n    var c = _c - b;\n    var v;\n    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);\n    return c - v + b;\n  },\n  easeOutBounce: function(t, b, _c, d) {\n    var c = _c - b;\n    if ((t /= d) < 1 / 2.75) {\n      return c * (7.5625 * t * t) + b;\n    } else if (t < 2 / 2.75) {\n      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n    } else if (t < 2.5 / 2.75) {\n      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n    } else {\n      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n    }\n  },\n  easeInOutBounce: function(t, b, _c, d) {\n    var c = _c - b;\n    var v;\n    if (t < d / 2) {\n      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);\n      return v * 0.5 + b;\n    } else {\n      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);\n      return v * 0.5 + c * 0.5 + b;\n    }\n  }\n};\n\nmodule.exports = tweenFunctions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90d2Vlbi1mdW5jdGlvbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXGJpbmdvLWNwXFxiaW5nby1jcFxcYmluZ28tY3BcXG5vZGVfbW9kdWxlc1xcdHdlZW4tZnVuY3Rpb25zXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIHQ6IGN1cnJlbnQgdGltZSwgYjogYmVnaW5uaW5nIHZhbHVlLCBfYzogZmluYWwgdmFsdWUsIGQ6IHRvdGFsIGR1cmF0aW9uXG52YXIgdHdlZW5GdW5jdGlvbnMgPSB7XG4gIGxpbmVhcjogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gYyAqIHQgLyBkICsgYjtcbiAgfSxcbiAgZWFzZUluUXVhZDogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gIH0sXG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG4gIH0sXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfVxuICB9LFxuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xuICB9LFxuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH0sXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcbiAgICB9XG4gIH0sXG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xuICB9LFxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfSxcbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICAgIH1cbiAgfSxcbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9LFxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcbiAgfSxcbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgICB9XG4gIH0sXG4gIGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgcmV0dXJuIC1jICogTWF0aC5jb3ModCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGMgKyBiO1xuICB9LFxuICBlYXNlT3V0U2luZTogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gYyAqIE1hdGguc2luKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBiO1xuICB9LFxuICBlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyBkKSAtIDEpICsgYjtcbiAgfSxcbiAgZWFzZUluRXhwbzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gKHQ9PTApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0L2QgLSAxKSkgKyBiO1xuICB9LFxuICBlYXNlT3V0RXhwbzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gKHQ9PWQpID8gYitjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdC9kKSArIDEpICsgYjtcbiAgfSxcbiAgZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmICh0ID09PSBkKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGMgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xuICAgIH1cbiAgfSxcbiAgZWFzZUluQ2lyYzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gLWMgKiAoTWF0aC5zcXJ0KDEgLSAodCAvPSBkKSAqIHQpIC0gMSkgKyBiO1xuICB9LFxuICBlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICByZXR1cm4gYyAqIE1hdGguc3FydCgxIC0gKHQgPSB0IC8gZCAtIDEpICogdCkgKyBiO1xuICB9LFxuICBlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICAgIH1cbiAgfSxcbiAgZWFzZUluRWxhc3RpYzogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICB2YXIgYSwgcCwgcztcbiAgICBzID0gMS43MDE1ODtcbiAgICBwID0gMDtcbiAgICBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmICgodCAvPSBkKSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICB9XG4gICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICsgYjtcbiAgfSxcbiAgZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgdmFyIGEsIHAsIHM7XG4gICAgcyA9IDEuNzAxNTg7XG4gICAgcCA9IDA7XG4gICAgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgaWYgKGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgYSA9IGM7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgfVxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIGMgKyBiO1xuICB9LFxuICBlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIHZhciBhLCBwLCBzO1xuICAgIHMgPSAxLjcwMTU4O1xuICAgIHAgPSAwO1xuICAgIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKCh0IC89IGQgLyAyKSA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgIGEgPSBjO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgIH1cbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKSArIGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyBjICsgYjtcbiAgICB9XG4gIH0sXG4gIGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQsIGIsIF9jLCBkLCBzKSB7XG4gICAgdmFyIGMgPSBfYyAtIGI7XG4gICAgaWYgKHMgPT09IHZvaWQgMCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICB9LFxuICBlYXNlT3V0QmFjazogZnVuY3Rpb24odCwgYiwgX2MsIGQsIHMpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICBpZiAocyA9PT0gdm9pZCAwKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0LCBiLCBfYywgZCwgcykge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIGlmIChzID09PSB2b2lkIDApIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgICB9XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICB2YXIgdjtcbiAgICB2ID0gdHdlZW5GdW5jdGlvbnMuZWFzZU91dEJvdW5jZShkIC0gdCwgMCwgYywgZCk7XG4gICAgcmV0dXJuIGMgLSB2ICsgYjtcbiAgfSxcbiAgZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCwgYiwgX2MsIGQpIHtcbiAgICB2YXIgYyA9IF9jIC0gYjtcbiAgICBpZiAoKHQgLz0gZCkgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICB9IGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMS41IC8gMi43NSkgKiB0ICsgMC43NSkgKyBiO1xuICAgIH0gZWxzZSBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAwLjk4NDM3NSkgKyBiO1xuICAgIH1cbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0LCBiLCBfYywgZCkge1xuICAgIHZhciBjID0gX2MgLSBiO1xuICAgIHZhciB2O1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHYgPSB0d2VlbkZ1bmN0aW9ucy5lYXNlSW5Cb3VuY2UodCAqIDIsIDAsIGMsIGQpO1xuICAgICAgcmV0dXJuIHYgKiAwLjUgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gdHdlZW5GdW5jdGlvbnMuZWFzZU91dEJvdW5jZSh0ICogMiAtIGQsIDAsIGMsIGQpO1xuICAgICAgcmV0dXJuIHYgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHdlZW5GdW5jdGlvbnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tween-functions/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/Loading.tsx":
/*!*****************************!*\
  !*** ./src/app/Loading.tsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Loading)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Loading() {\n    _s();\n    const [dots, setDots] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Loading.useEffect\": ()=>{\n            const interval = setInterval({\n                \"Loading.useEffect.interval\": ()=>{\n                    setDots({\n                        \"Loading.useEffect.interval\": (prev)=>prev.length < 3 ? prev + '.' : ''\n                    }[\"Loading.useEffect.interval\"]);\n                }\n            }[\"Loading.useEffect.interval\"], 500);\n            return ({\n                \"Loading.useEffect\": ()=>clearInterval(interval)\n            })[\"Loading.useEffect\"];\n        }\n    }[\"Loading.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: 'flex',\n            height: '40vh',\n            alignItems: 'center',\n            justifyContent: 'center',\n            fontSize: '2rem',\n            fontWeight: 'bold'\n        },\n        children: [\n            \"Loading problems\",\n            dots\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\Loading.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, this);\n}\n_s(Loading, \"x5A7Sg53ZjAlz59b/ycs4VK0Y+g=\");\n_c = Loading;\nvar _c;\n$RefreshReg$(_c, \"Loading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvTG9hZGluZy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTRDO0FBRTdCLFNBQVNFOztJQUN0QixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR0gsK0NBQVFBLENBQUM7SUFFakNELGdEQUFTQTs2QkFBQztZQUNSLE1BQU1LLFdBQVdDOzhDQUFZO29CQUMzQkY7c0RBQVEsQ0FBQ0csT0FBVUEsS0FBS0MsTUFBTSxHQUFHLElBQUlELE9BQU8sTUFBTTs7Z0JBQ3BEOzZDQUFHO1lBQ0g7cUNBQU8sSUFBTUUsY0FBY0o7O1FBQzdCOzRCQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ0s7UUFBSUMsT0FBTztZQUNWQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxnQkFBZ0I7WUFDaEJDLFVBQVU7WUFDVkMsWUFBWTtRQUNkOztZQUFHO1lBQ2dCZDs7Ozs7OztBQUd2QjtHQXRCd0JEO0tBQUFBIiwic291cmNlcyI6WyJEOlxcYmluZ28tY3BcXGJpbmdvLWNwXFxiaW5nby1jcFxcc3JjXFxhcHBcXExvYWRpbmcudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTG9hZGluZygpIHtcbiAgY29uc3QgW2RvdHMsIHNldERvdHNdID0gdXNlU3RhdGUoJycpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXREb3RzKChwcmV2KSA9PiAocHJldi5sZW5ndGggPCAzID8gcHJldiArICcuJyA6ICcnKSk7XG4gICAgfSwgNTAwKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGhlaWdodDogJzQwdmgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICBmb250U2l6ZTogJzJyZW0nLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgIH19PlxuICAgICAgTG9hZGluZyBwcm9ibGVtc3tkb3RzfVxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiTG9hZGluZyIsImRvdHMiLCJzZXREb3RzIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJsZW5ndGgiLCJjbGVhckludGVydmFsIiwiZGl2Iiwic3R5bGUiLCJkaXNwbGF5IiwiaGVpZ2h0IiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZm9udFNpemUiLCJmb250V2VpZ2h0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Loading.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/match/[id]/page.tsx":
/*!*************************************!*\
  !*** ./src/app/match/[id]/page.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _Loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Loading */ \"(app-pages-browser)/./src/app/Loading.tsx\");\n/* harmony import */ var react_confetti__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-confetti */ \"(app-pages-browser)/./node_modules/react-confetti/dist/react-confetti.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n // add to top imports if not present\nconst teamColors = {\n    red: 'bg-red-500',\n    blue: 'bg-blue-500',\n    green: 'bg-green-500',\n    purple: 'bg-purple-500',\n    orange: 'bg-orange-500',\n    pink: 'bg-pink-500',\n    yellow: 'bg-yellow-500',\n    teal: 'bg-teal-500'\n};\nconst links = {\n    \"Home\": 'http://localhost:3000/home',\n    \"ICPC Mode\": 'http://localhost:3000/create-match',\n    \"IOI Mode\": 'http://localhost:3000/oi_mode',\n    \"Help\": 'http://localhost:3000/help'\n};\nconst gridClasses = {\n    3: \"grid-cols-3 gap-x-0 gap-y-4 justify-items-center mt-4 mx-130\",\n    4: \"grid-cols-4 gap-x-0 gap-y-4 justify-items-center mt-4 mx-110\",\n    5: \"grid-cols-5 gap-x-0 gap-y-4 justify-items-center mt-4 mx-90\",\n    6: \"grid-cols-6 gap-x-0 gap-y-4 justify-items-center mt-4 mx-70\"\n};\n// small local hook, avoids react-use dependency\nfunction useWindowSize() {\n    _s();\n    const isClient = \"object\" !== 'undefined';\n    const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: isClient ? window.innerWidth : 0,\n        height: isClient ? window.innerHeight : 0\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useWindowSize.useEffect\": ()=>{\n            if (!isClient) return;\n            function onResize() {\n                setSize({\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                });\n            }\n            window.addEventListener('resize', onResize);\n            onResize();\n            return ({\n                \"useWindowSize.useEffect\": ()=>window.removeEventListener('resize', onResize)\n            })[\"useWindowSize.useEffect\"];\n        }\n    }[\"useWindowSize.useEffect\"], [\n        isClient\n    ]);\n    return size;\n}\n_s(useWindowSize, \"EHsdXo7pyf9gX725TsIkXVc9MjA=\");\nfunction notifyBrowser(title, body) {\n    // Request permission if needed\n    if ( false || !('Notification' in window)) return;\n    if (Notification.permission === 'granted') {\n        try {\n            new Notification(title, {\n                body\n            });\n        } catch (e) {}\n        return;\n    }\n    if (Notification.permission !== 'denied') {\n        Notification.requestPermission().then((permission)=>{\n            if (permission === 'granted') {\n                try {\n                    new Notification(title, {\n                        body\n                    });\n                } catch (e) {}\n            }\n        });\n    }\n}\n// normalize/dedupe server problems: prefer position, fall back to contestId-index\nfunction normalizeProblemsFromServer(raw) {\n    if (!Array.isArray(raw)) return [];\n    // keep only active (defensive)\n    const active = raw.filter((p)=>p && p.active !== false);\n    // If problems have `position`, use a Map keyed by position (keeps slot count stable)\n    const hasPosition = active.every((p)=>typeof p.position === 'number');\n    if (hasPosition) {\n        const byPos = new Map();\n        for (const p of active){\n            const pos = p.position;\n            // if duplicates for same position exist, keep the first one (server should avoid this)\n            if (!byPos.has(pos)) byPos.set(pos, p);\n        // optionally: if you want newest: always overwrite byPos.set(pos, p)\n        }\n        // Create array ordered by position (fill gaps if you want with nulls  we sort)\n        return Array.from(byPos.entries()).sort((a, b)=>a[0] - b[0]).map((param)=>{\n            let [_, p] = param;\n            return p;\n        });\n    }\n    // Fallback: dedupe by contestId-index key and preserve server order\n    const seen = new Set();\n    const result = [];\n    for (const p of active){\n        const key = \"\".concat(p.contestId, \"-\").concat(p.index);\n        if (!seen.has(key)) {\n            seen.add(key);\n            result.push(p);\n        }\n    }\n    return result;\n}\nfunction Home() {\n    _s1();\n    var _s = $RefreshSig$();\n    const params = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useParams)();\n    const rawId = params === null || params === void 0 ? void 0 : params.id;\n    const id = Array.isArray(rawId) ? rawId[0] : rawId; // id is now string | undefined\n    // const [isDarkMode, setIsDarkMode] = useState(false);\n    const [showLog, setShowLog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [currentTeam, setCurrentTeam] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [problems, setProblems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [gridSize, setgridSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(5);\n    const [solved, setSolved] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [log, setLog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [match, setMatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [now, setNow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Date());\n    // win / lock / confetti state\n    const [winner, setWinner] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [matchLocked, setMatchLocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // prevents further marking/polling after win\n    const [confettiActive, setConfettiActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [positionOwners, setPositionOwners] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    // window size (use the local hook)\n    const { width, height } = useWindowSize();\n    //   const [activeTab, setActiveTab] = useState(\"Home\");\n    const notifiedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    function persistNotified(matchId) {\n        const key = \"notified_\".concat(matchId);\n        try {\n            localStorage.setItem(key, JSON.stringify(Array.from(notifiedRef.current)));\n        } catch (e) {}\n    }\n    // restore from localStorage when match loads (once per match)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!(match === null || match === void 0 ? void 0 : match.id)) return;\n            const key = \"notified_\".concat(match.id);\n            const raw = localStorage.getItem(key);\n            try {\n                const arr = raw ? JSON.parse(raw) : [];\n                notifiedRef.current = new Set(arr);\n            } catch (e) {\n                notifiedRef.current = new Set();\n            }\n        }\n    }[\"Home.useEffect\"], [\n        match === null || match === void 0 ? void 0 : match.id\n    ]);\n    // --- Fetch match by id on mount / when id changes ---\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!id) return;\n            setLoading(true);\n            const fetchMatch = {\n                \"Home.useEffect.fetchMatch\": async ()=>{\n                    try {\n                        const res = await fetch(\"/api/getMatch?matchId=\".concat(encodeURIComponent(id)));\n                        if (!res.ok) {\n                            console.error('Failed to fetch match', await res.text());\n                            setMatch(null);\n                            setLoading(false);\n                            return;\n                        }\n                        const data = await res.json();\n                        var _data_match;\n                        // If your API returns { match } use data.match, otherwise data (adjust if needed)\n                        const matchObj = (_data_match = data.match) !== null && _data_match !== void 0 ? _data_match : data;\n                        setMatch(matchObj);\n                        // Build solved map + log from returned match's solveLog (so page shows final results if match already ended)\n                        try {\n                            const solvedMap = {};\n                            const newLogEntries = [];\n                            const posOwners = {};\n                            var _matchObj_teams;\n                            // console.log(\"FSS: \", matchObj.teams);\n                            const teamsFromServer = (_matchObj_teams = matchObj.teams) !== null && _matchObj_teams !== void 0 ? _matchObj_teams : [];\n                            var // console.log(\"mys: \", matchObj.solveLog);\n                            _matchObj_solveLog;\n                            ((_matchObj_solveLog = matchObj.solveLog) !== null && _matchObj_solveLog !== void 0 ? _matchObj_solveLog : []).forEach({\n                                \"Home.useEffect.fetchMatch\": (entry)=>{\n                                    var _entry_problem;\n                                    const key = \"\".concat(entry.contestId, \"-\").concat(entry.index);\n                                    const { displayName, teamKey } = resolveTeamDisplayAndKey(entry.team, teamsFromServer);\n                                    solvedMap[entry.problem.position] = {\n                                        team: teamKey\n                                    };\n                                    // If solveLog includes the problem relation and it has a position, map position -> owner\n                                    if (entry.problem && typeof entry.problem.position === 'number') {\n                                        posOwners[entry.problem.position] = teamKey;\n                                    }\n                                    var _entry_problem_name;\n                                    // use problem name if included by API, otherwise fall back to index\n                                    const problemName = (_entry_problem_name = (_entry_problem = entry.problem) === null || _entry_problem === void 0 ? void 0 : _entry_problem.name) !== null && _entry_problem_name !== void 0 ? _entry_problem_name : \"Problem \".concat(entry.index);\n                                    const contestAndIndex = \"\".concat(entry.contestId).concat(entry.index);\n                                    newLogEntries.push({\n                                        key,\n                                        message: \"\".concat(displayName, \" solved \").concat(problemName, \" (\").concat(contestAndIndex, \")\"),\n                                        team: teamKey\n                                    });\n                                // newLogEntries.push({\n                                // message: `${entry.team} solved ${problemName} (${contestAndIndex})`,\n                                // team: entry.team.toLowerCase(),\n                                // });\n                                }\n                            }[\"Home.useEffect.fetchMatch\"]);\n                            // console.log(\"MS: \", solvedMap);\n                            setPositionOwners(posOwners); // <-- set state\n                            // merge with any existing log (keep newest first) but avoid duplicates\n                            setLog({\n                                \"Home.useEffect.fetchMatch\": (prev)=>{\n                                    const combined = [\n                                        ...newLogEntries,\n                                        ...prev\n                                    ];\n                                    const uniqueMap = new Map();\n                                    for (const e of combined){\n                                        if (!uniqueMap.has(e.key)) uniqueMap.set(e.key, e);\n                                    }\n                                    return Array.from(uniqueMap.values()).slice(0, 10);\n                                }\n                            }[\"Home.useEffect.fetchMatch\"]);\n                            setSolved(solvedMap);\n                        // AFTER setLog(...) inside the initial fetch try block:\n                        // if (matchObj?.id) {\n                        //   // Mark initial historic messages as notified so new tab won't re-notify them\n                        //   newLogEntries.forEach(ne => notifiedRef.current.add(ne.message));\n                        //   persistNotified(matchObj.id);\n                        // }\n                        } catch (e) {\n                            // don't crash if shape is unexpected\n                            console.warn('Could not build solved/log from matchObj.solveLog', e);\n                        }\n                    } catch (err) {\n                        console.error('Error fetching match', err);\n                    } finally{\n                        setLoading(false);\n                    }\n                }\n            }[\"Home.useEffect.fetchMatch\"];\n            fetchMatch();\n        }\n    }[\"Home.useEffect\"], [\n        id\n    ]);\n    // helper to map an entry.team (which might be color or name) to displayName and color key\n    // helper to map an entry.team (which might be color or name) to displayName and color key\n    // helper to map an entry.team (which might be color or name) to displayName and color key\n    function resolveTeamDisplayAndKey(teamIdentifier, teamsListParam) {\n        var _match_teams;\n        // prefer explicit list passed in; fallback to current match state\n        const teamsList = teamsListParam !== null && teamsListParam !== void 0 ? teamsListParam : (_match_teams = match === null || match === void 0 ? void 0 : match.teams) !== null && _match_teams !== void 0 ? _match_teams : [];\n        if (!teamIdentifier) return {\n            displayName: 'Unknown',\n            teamKey: 'unknown'\n        };\n        const search = teamIdentifier.toLowerCase();\n        // console.log(\"TeamsSSSS: \", teamsList);\n        const teamObj = teamsList.find((t)=>{\n            var _t_color, _t_name;\n            return ((_t_color = t.color) !== null && _t_color !== void 0 ? _t_color : '').toLowerCase() === search || ((_t_name = t.name) !== null && _t_name !== void 0 ? _t_name : '').toLowerCase() === search;\n        });\n        var _teamObj_name;\n        // console.log('TEAMS: ', match?.teams);\n        const displayName = (_teamObj_name = teamObj === null || teamObj === void 0 ? void 0 : teamObj.name) !== null && _teamObj_name !== void 0 ? _teamObj_name : teamIdentifier;\n        var _teamObj_color, _ref;\n        const teamKey = ((_ref = (_teamObj_color = teamObj === null || teamObj === void 0 ? void 0 : teamObj.color) !== null && _teamObj_color !== void 0 ? _teamObj_color : teamIdentifier) !== null && _ref !== void 0 ? _ref : 'unknown').toLowerCase();\n        return {\n            displayName,\n            teamKey\n        };\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            var _match_teams;\n            if ((match === null || match === void 0 ? void 0 : (_match_teams = match.teams) === null || _match_teams === void 0 ? void 0 : _match_teams.length) && !currentTeam) {\n                // store color key as currentTeam (recommended)\n                setCurrentTeam(match.teams[0].color);\n            // OR setCurrentTeam(match.teams[0].name) if you prefer storing display names\n            }\n        }\n    }[\"Home.useEffect\"], [\n        match\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (matchLocked) return; // don't poll/merge updates after a win/lock\n            if (!(match === null || match === void 0 ? void 0 : match.id)) return;\n            const matchStart = new Date(match.startTime);\n            const matchEnd = new Date(matchStart.getTime() + match.durationMinutes * 60 * 1000);\n            const fetchPoll = {\n                \"Home.useEffect.fetchPoll\": async ()=>{\n                    const now = new Date();\n                    if (now < matchStart || now > matchEnd) {\n                        // Don't poll outside match time\n                        return;\n                    }\n                    try {\n                        const pollRes = await fetch('/api/poll-submissions', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify({\n                                matchId: match.id\n                            })\n                        });\n                        const pollData = await pollRes.json();\n                        if (pollData.updated && pollData.match) {\n                            var _pollData_match, _pollData_match1;\n                            setMatch(pollData.match);\n                            // Build solved map\n                            const solvedMap = {};\n                            const newLogEntries = [];\n                            const posOwners = {};\n                            const problemUpdates = {};\n                            var _pollData_match_teams;\n                            const teamsFromServer = (_pollData_match_teams = (_pollData_match = pollData.match) === null || _pollData_match === void 0 ? void 0 : _pollData_match.teams) !== null && _pollData_match_teams !== void 0 ? _pollData_match_teams : [];\n                            pollData.match.solveLog.forEach({\n                                \"Home.useEffect.fetchPoll\": (entry)=>{\n                                    var _entry_problem;\n                                    const key = \"\".concat(entry.contestId, \"-\").concat(entry.index);\n                                    // console.log(\"ResS :\", teamsFromServer);\n                                    const { displayName, teamKey } = resolveTeamDisplayAndKey(entry.team, teamsFromServer);\n                                    solvedMap[key] = {\n                                        team: teamKey\n                                    };\n                                    // If solveLog includes the problem relation and it has a position, map position -> owner\n                                    if (entry.problem && typeof entry.problem.position === 'number') {\n                                        posOwners[entry.problem.position] = teamKey;\n                                    }\n                                    if (entry.problem) {\n                                        var _entry_problem_name, _entry_problem_rating;\n                                        problemUpdates[key] = {\n                                            name: (_entry_problem_name = entry.problem.name) !== null && _entry_problem_name !== void 0 ? _entry_problem_name : undefined,\n                                            rating: (_entry_problem_rating = entry.problem.rating) !== null && _entry_problem_rating !== void 0 ? _entry_problem_rating : undefined,\n                                            contestId: entry.contestId,\n                                            index: entry.index\n                                        };\n                                    }\n                                    var _entry_problem_name1;\n                                    // Add to new log entries\n                                    const problemName = (_entry_problem_name1 = (_entry_problem = entry.problem) === null || _entry_problem === void 0 ? void 0 : _entry_problem.name) !== null && _entry_problem_name1 !== void 0 ? _entry_problem_name1 : \"Problem \".concat(entry.index);\n                                    const contestAndIndex = \"\".concat(entry.contestId).concat(entry.index);\n                                    newLogEntries.push({\n                                        key,\n                                        message: \"\".concat(displayName, \" solved \").concat(problemName, \" (\").concat(contestAndIndex, \")\"),\n                                        team: teamKey\n                                    });\n                                }\n                            }[\"Home.useEffect.fetchPoll\"]);\n                            setSolved(solvedMap);\n                            setPositionOwners(posOwners); // <-- set state\n                            if (((_pollData_match1 = pollData.match) === null || _pollData_match1 === void 0 ? void 0 : _pollData_match1.problems) && Array.isArray(pollData.match.problems)) {\n                                const normalized = normalizeProblemsFromServer(pollData.match.problems);\n                                setProblems(normalized);\n                            } else if (Object.keys(problemUpdates).length > 0) {\n                                setProblems({\n                                    \"Home.useEffect.fetchPoll\": (prev)=>prev.map({\n                                            \"Home.useEffect.fetchPoll\": (p)=>{\n                                                const k = \"\".concat(p.contestId, \"-\").concat(p.index);\n                                                const upd = problemUpdates[k];\n                                                if (!upd) return p;\n                                                var _upd_name, _upd_rating, _upd_contestId, _upd_index;\n                                                return {\n                                                    ...p,\n                                                    // only override fields provided by server\n                                                    name: (_upd_name = upd.name) !== null && _upd_name !== void 0 ? _upd_name : p.name,\n                                                    rating: (_upd_rating = upd.rating) !== null && _upd_rating !== void 0 ? _upd_rating : p.rating,\n                                                    // contestId/index normally unchanged, but included for completeness:\n                                                    contestId: (_upd_contestId = upd.contestId) !== null && _upd_contestId !== void 0 ? _upd_contestId : p.contestId,\n                                                    index: (_upd_index = upd.index) !== null && _upd_index !== void 0 ? _upd_index : p.index\n                                                };\n                                            }\n                                        }[\"Home.useEffect.fetchPoll\"])\n                                }[\"Home.useEffect.fetchPoll\"]);\n                            }\n                            // then publish owners/solved so UI can map by problem.position reliably\n                            setSolved(solvedMap);\n                            setPositionOwners(posOwners);\n                            // Update log: either replace entirely or merge with previous log\n                            // Here, just replace with latest from DB (or merge if you want)\n                            setLog({\n                                \"Home.useEffect.fetchPoll\": (prevLog)=>{\n                                    var _pollData_match;\n                                    const combined = [\n                                        ...newLogEntries,\n                                        ...prevLog\n                                    ];\n                                    const uniqueMap = new Map();\n                                    for (const entry of combined){\n                                        if (!uniqueMap.has(entry.key)) uniqueMap.set(entry.key, entry);\n                                    }\n                                    const deduped = Array.from(uniqueMap.values()).slice(0, 10);\n                                    // notify only for messages not in prevLog\n                                    const prevMessages = new Set(prevLog.map({\n                                        \"Home.useEffect.fetchPoll\": (x)=>x.message\n                                    }[\"Home.useEffect.fetchPoll\"]));\n                                    newLogEntries.forEach({\n                                        \"Home.useEffect.fetchPoll\": (ne)=>{\n                                            if (!prevMessages.has(ne.message) && !notifiedRef.current.has(ne.message)) {\n                                                // send notification\n                                                notifyBrowser(\"Solve reported\", ne.message);\n                                                // mark as notified and persist\n                                                notifiedRef.current.add(ne.message);\n                                            }\n                                        }\n                                    }[\"Home.useEffect.fetchPoll\"]);\n                                    // persist updated notified set\n                                    if ((_pollData_match = pollData.match) === null || _pollData_match === void 0 ? void 0 : _pollData_match.id) persistNotified(pollData.match.id);\n                                    return deduped;\n                                }\n                            }[\"Home.useEffect.fetchPoll\"]);\n                        }\n                    } catch (err) {\n                        console.error('Polling submissions failed', err);\n                    }\n                }\n            }[\"Home.useEffect.fetchPoll\"];\n            fetchPoll();\n            const interval = setInterval(fetchPoll, 10000); // REMEMBER TO CHANGE TO 15S\n            return ({\n                \"Home.useEffect\": ()=>clearInterval(interval)\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        match === null || match === void 0 ? void 0 : match.id,\n        match === null || match === void 0 ? void 0 : match.startTime,\n        match === null || match === void 0 ? void 0 : match.durationMinutes,\n        matchLocked\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            const interval = setInterval({\n                \"Home.useEffect.interval\": ()=>{\n                    setNow(new Date());\n                }\n            }[\"Home.useEffect.interval\"], 1000);\n            return ({\n                \"Home.useEffect\": ()=>clearInterval(interval)\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!match) return;\n            const start = new Date(match.startTime);\n            const end = new Date(start.getTime() + match.durationMinutes * 60 * 1000);\n            const now = new Date();\n            if (now >= end) {\n                setMatchLocked(true);\n            }\n        }\n    }[\"Home.useEffect\"], [\n        match\n    ]);\n    // Fetch problems when match changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            var _match_problems;\n            if (!match) return;\n            var _match_problems_length;\n            // console.log(\"for crying out loud: \", match.problems)\n            const len = (_match_problems_length = (_match_problems = match.problems) === null || _match_problems === void 0 ? void 0 : _match_problems.length) !== null && _match_problems_length !== void 0 ? _match_problems_length : 0;\n            if (len === 36) setgridSize(6);\n            else if (len === 25) setgridSize(5);\n            else if (len === 16) setgridSize(4);\n            else setgridSize(3);\n            // Normalize incoming problems to avoid duplicates / unexpected increases\n            const normalized = normalizeProblemsFromServer(match.problems || []);\n            setProblems(normalized); // problems now have contestId, index, name, rating, position\n            setLoading(false);\n        }\n    }[\"Home.useEffect\"], [\n        match\n    ]);\n    function formatDuration(ms) {\n        // console.log(\"Num: \", ms)\n        // console.log(\"match.startTime:\", match?.startTime);\n        // console.log(\"start: \", Date.now())\n        // console.log(\"NOOOOOOOOOOOOOOOOOLSDKFJLSDKFHLAKSHFLKSDJFLKHSDLFKJLNONONONONON\")\n        const totalSeconds = Math.max(0, Math.floor(ms / 1000));\n        const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, \"0\");\n        const minutes = String(Math.floor(totalSeconds % 3600 / 60)).padStart(2, \"0\");\n        const seconds = String(totalSeconds % 60).padStart(2, \"0\");\n        return \"\".concat(hours, \":\").concat(minutes, \":\").concat(seconds);\n    }\n    function formatCountdown(ms) {\n        if (ms <= 0) return \"00:00:00\";\n        const totalSeconds = Math.floor(ms / 1000);\n        const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, \"0\");\n        const minutes = Math.floor(totalSeconds % 3600 / 60).toString().padStart(2, \"0\");\n        const seconds = (totalSeconds % 60).toString().padStart(2, \"0\");\n        return \"\".concat(hours, \":\").concat(minutes, \":\").concat(seconds);\n    }\n    function CountdownToStart(param) {\n        let { startTime } = param;\n        _s();\n        const [timeLeft, setTimeLeft] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n            \"Home.CountdownToStart.useState\": ()=>startTime.getTime() - Date.now()\n        }[\"Home.CountdownToStart.useState\"]);\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n            \"Home.CountdownToStart.useEffect\": ()=>{\n                const interval = setInterval({\n                    \"Home.CountdownToStart.useEffect.interval\": ()=>{\n                        setTimeLeft(startTime.getTime() - Date.now());\n                    }\n                }[\"Home.CountdownToStart.useEffect.interval\"], 1000);\n                return ({\n                    \"Home.CountdownToStart.useEffect\": ()=>clearInterval(interval)\n                })[\"Home.CountdownToStart.useEffect\"];\n            }\n        }[\"Home.CountdownToStart.useEffect\"], [\n            startTime\n        ]);\n        if (timeLeft <= 0) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Match is starting now...\"\n            }, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 506,\n                columnNumber: 14\n            }, this);\n        }\n        const minutes = Math.floor(timeLeft / 60000);\n        const seconds = Math.floor(timeLeft % 60000 / 1000);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"text-yellow-500\",\n            children: [\n                \"Match starts in \",\n                formatDuration(startTime.getTime() - Date.now())\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n            lineNumber: 513,\n            columnNumber: 7\n        }, this);\n    }\n    _s(CountdownToStart, \"3T6381qpeI/cVklkZj00PExWeaY=\");\n    // useEffect(() => {\n    //   const theme = localStorage.getItem('theme');\n    //   const prefersDark = theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches);\n    //   setIsDarkMode(prefersDark);\n    //   document.documentElement.classList.toggle('dark', prefersDark);\n    // }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            // console.log(\"HHHEHEHE:\", problems);\n            if (!problems || problems.length === 0) return;\n            if (matchLocked) return; // already locked\n            // console.log(\"HHHEHEHE:\")\n            const w = findWinnerFromSolved(solved, problems, gridSize);\n            // console.log(\"P: \", w);\n            if (w && !winner) {\n                var _match_teams, _teamObj_color, _currentTeam_toLowerCase;\n                setWinner(w);\n                setConfettiActive(true);\n                setMatchLocked(true);\n                const teamObj = match === null || match === void 0 ? void 0 : (_match_teams = match.teams) === null || _match_teams === void 0 ? void 0 : _match_teams.find({\n                    \"Home.useEffect\": (t)=>{\n                        var _t_color, _t_name;\n                        return ((_t_color = t.color) === null || _t_color === void 0 ? void 0 : _t_color.toLowerCase()) === (currentTeam === null || currentTeam === void 0 ? void 0 : currentTeam.toLowerCase()) || ((_t_name = t.name) === null || _t_name === void 0 ? void 0 : _t_name.toLowerCase()) === (currentTeam === null || currentTeam === void 0 ? void 0 : currentTeam.toLowerCase());\n                    }\n                }[\"Home.useEffect\"]);\n                var _teamObj_name;\n                // display name (for UI) and key (for internal use)\n                // console.log('displayName: ', teamObj?.name)\n                const displayName = (_teamObj_name = teamObj === null || teamObj === void 0 ? void 0 : teamObj.name) !== null && _teamObj_name !== void 0 ? _teamObj_name : currentTeam;\n                var _teamObj_color_toLowerCase, _ref;\n                const teamKey = (_ref = (_teamObj_color_toLowerCase = teamObj === null || teamObj === void 0 ? void 0 : (_teamObj_color = teamObj.color) === null || _teamObj_color === void 0 ? void 0 : _teamObj_color.toLowerCase()) !== null && _teamObj_color_toLowerCase !== void 0 ? _teamObj_color_toLowerCase : currentTeam === null || currentTeam === void 0 ? void 0 : (_currentTeam_toLowerCase = currentTeam.toLowerCase) === null || _currentTeam_toLowerCase === void 0 ? void 0 : _currentTeam_toLowerCase.call(currentTeam)) !== null && _ref !== void 0 ? _ref : 'unknown';\n                // add final summary line to the log\n                // const key = `${problems[i].contestId}-${problems[i].index}`;\n                setLog({\n                    \"Home.useEffect\": (prev)=>{\n                        const problemList = w.keys.map({\n                            \"Home.useEffect.problemList\": (k)=>k.replace('-', '')\n                        }[\"Home.useEffect.problemList\"]).join(', '); // basic formatting\n                        const finalMsg = \"\".concat(displayName, \" completed \").concat(w.type === 'row' ? 'a row' : w.type === 'col' ? 'a column' : w.type === 'diag' ? 'the main diagonal' : 'the anti-diagonal');\n                        return [\n                            {\n                                message: finalMsg,\n                                team: w.team.toLowerCase(),\n                                key: \"\"\n                            },\n                            ...prev\n                        ].slice(0, 10);\n                    }\n                }[\"Home.useEffect\"]);\n            // OPTIONAL: persist a lock on the server (if you add a /api/lockMatch endpoint)\n            // fetch('/api/lockMatch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ matchId: match?.id }) }).catch(console.warn);\n            }\n        }\n    }[\"Home.useEffect\"], [\n        solved,\n        problems,\n        winner\n    ]);\n    // function toggleTheme() {\n    //   const newTheme = !isDarkMode;\n    //   setIsDarkMode(newTheme);\n    //   localStorage.setItem('theme', newTheme ? 'dark' : 'light');\n    //   document.documentElement.classList.toggle('dark', newTheme);\n    // }\n    function findWinnerFromSolved(solvedMap, problemsArr, gSize) {\n        // console.log(\"PPP: \", problemsArr);\n        // console.log(\":P: \", solvedMap);\n        if (!problemsArr || problemsArr.length === 0) return null;\n        const size = gSize;\n        // Defensive: ensure problemsArr length matches expected grid size (size * size).\n        // If it doesn't, bail out and avoid index OOB. Log for debugging.\n        if (problemsArr.length !== size * size) {\n            console.warn(\"findWinnerFromSolved: mismatch problems.length (\".concat(problemsArr.length, \") vs expected (\").concat(size * size, \"). Skipping winner detection.\"));\n            return null;\n        }\n        // owner grid: team name string | null\n        const ownerGrid = Array.from({\n            length: size\n        }, ()=>Array(size).fill(null));\n        for(let i = 0; i < problemsArr.length; i++){\n            var _solvedMap_i;\n            const r = Math.floor(i / size);\n            const c = i % size;\n            var _solvedMap_i_team;\n            ownerGrid[r][c] = (_solvedMap_i_team = (_solvedMap_i = solvedMap[i]) === null || _solvedMap_i === void 0 ? void 0 : _solvedMap_i.team) !== null && _solvedMap_i_team !== void 0 ? _solvedMap_i_team : null;\n        }\n        // rows\n        for(let r = 0; r < size; r++){\n            const first = ownerGrid[r][0];\n            if (first && ownerGrid[r].every((cell)=>cell === first)) {\n                const keys = Array.from({\n                    length: size\n                }, (_, c)=>\"\".concat(problemsArr[r * size + c].contestId, \"-\").concat(problemsArr[r * size + c].index));\n                return {\n                    team: first,\n                    type: 'row',\n                    index: r,\n                    keys\n                };\n            }\n        }\n        // columns\n        for(let c = 0; c < size; c++){\n            const first = ownerGrid[0][c];\n            if (first && ownerGrid.every((row)=>row[c] === first)) {\n                const keys = Array.from({\n                    length: size\n                }, (_, r)=>\"\".concat(problemsArr[r * size + c].contestId, \"-\").concat(problemsArr[r * size + c].index));\n                return {\n                    team: first,\n                    type: 'col',\n                    index: c,\n                    keys\n                };\n            }\n        }\n        // main diagonal\n        const firstDiag = ownerGrid[0][0];\n        if (firstDiag && ownerGrid.every((row, i)=>row[i] === firstDiag)) {\n            const keys = Array.from({\n                length: size\n            }, (_, i)=>\"\".concat(problemsArr[i * size + i].contestId, \"-\").concat(problemsArr[i * size + i].index));\n            return {\n                team: firstDiag,\n                type: 'diag',\n                index: 0,\n                keys\n            };\n        }\n        // anti-diagonal\n        const firstAnti = ownerGrid[0][size - 1];\n        if (firstAnti && ownerGrid.every((row, i)=>row[size - 1 - i] === firstAnti)) {\n            const keys = Array.from({\n                length: size\n            }, (_, i)=>\"\".concat(problemsArr[i * size + (size - 1 - i)].contestId, \"-\").concat(problemsArr[i * size + (size - 1 - i)].index));\n            return {\n                team: firstAnti,\n                type: 'anti-diag',\n                index: 1,\n                keys\n            };\n        }\n        return null;\n    }\n    function toggleSquare(i) {\n        var _match_teams, _teamObj_color, _currentTeam_toLowerCase;\n        if (matchLocked) return;\n        const key = \"\".concat(problems[i].contestId, \"-\").concat(problems[i].index);\n        if (solved[key]) return;\n        const time = new Date().toLocaleTimeString();\n        setSolved((prev)=>({\n                ...prev,\n                [key]: {\n                    team: currentTeam,\n                    timestamp: time\n                }\n            }));\n        const prob = problems[i];\n        const problemId = \"\".concat(prob.contestId).concat(prob.index);\n        const teamObj = match === null || match === void 0 ? void 0 : (_match_teams = match.teams) === null || _match_teams === void 0 ? void 0 : _match_teams.find((t)=>{\n            var _t_color, _t_name;\n            return ((_t_color = t.color) === null || _t_color === void 0 ? void 0 : _t_color.toLowerCase()) === (currentTeam === null || currentTeam === void 0 ? void 0 : currentTeam.toLowerCase()) || ((_t_name = t.name) === null || _t_name === void 0 ? void 0 : _t_name.toLowerCase()) === (currentTeam === null || currentTeam === void 0 ? void 0 : currentTeam.toLowerCase());\n        });\n        var _teamObj_name;\n        // console.log('the teams: ', match?.teams);\n        // display name (for UI) and key (for internal use)\n        // console.log('displayName: ', teamObj?.name)\n        const displayName = (_teamObj_name = teamObj === null || teamObj === void 0 ? void 0 : teamObj.name) !== null && _teamObj_name !== void 0 ? _teamObj_name : currentTeam;\n        var _teamObj_color_toLowerCase, _ref;\n        const teamKey = (_ref = (_teamObj_color_toLowerCase = teamObj === null || teamObj === void 0 ? void 0 : (_teamObj_color = teamObj.color) === null || _teamObj_color === void 0 ? void 0 : _teamObj_color.toLowerCase()) !== null && _teamObj_color_toLowerCase !== void 0 ? _teamObj_color_toLowerCase : currentTeam === null || currentTeam === void 0 ? void 0 : (_currentTeam_toLowerCase = currentTeam.toLowerCase) === null || _currentTeam_toLowerCase === void 0 ? void 0 : _currentTeam_toLowerCase.call(currentTeam)) !== null && _ref !== void 0 ? _ref : 'unknown';\n        // console.log('Name: ', displayName);\n        const newEntry = {\n            key,\n            message: \"\".concat(displayName, \" solved \").concat(prob.name, \" (\").concat(problemId, \")\"),\n            team: teamKey\n        };\n        setLog((prev)=>{\n            //   const newEntry = {\n            //     message: `${time}  ${currentTeam} solved ${problems[i].name}`,\n            //     team: currentTeam.toLowerCase(), // make sure team matches keys in teamColors\n            //   };\n            const combined = [\n                newEntry,\n                ...prev\n            ];\n            // Optional: remove duplicate messages if needed\n            const uniqueMap = new Map();\n            for (const entry of combined){\n                if (!uniqueMap.has(entry.key)) {\n                    uniqueMap.set(entry.key, entry);\n                }\n            }\n            return Array.from(uniqueMap.values()).slice(0, 10);\n        });\n    }\n    // ======= EARLY RETURN if no match ===========\n    if (loading) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Loading__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n        lineNumber: 667,\n        columnNumber: 23\n    }, this); // while fetching\n    if (!match) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n            className: \"p-6\",\n            children: \"Match not found\"\n        }, void 0, false, {\n            fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n            lineNumber: 669,\n            columnNumber: 12\n        }, this);\n    }\n    // ==== MATCH IS NOT NULL BELOW, SAFE TO USE match START ====\n    const matchStart = new Date(match.startTime);\n    const matchEnd = new Date(matchStart.getTime() + match.durationMinutes * 60 * 1000);\n    const currentTime = new Date();\n    const matchHasStarted = currentTime >= matchStart;\n    const matchHasEnded = currentTime >= matchEnd;\n    const matchOngoing = matchHasStarted && !matchHasEnded && !matchLocked;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"min-h-screen bg-white dark:bg-gray-900 dark:text-gray-100 transition-colors duration-300\",\n        children: [\n            winner && confettiActive && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_confetti__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                width: width,\n                height: height,\n                recycle: false,\n                numberOfPieces: 300\n            }, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 686,\n                columnNumber: 42\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"w-full bg-gray-100 dark:bg-gray-800 border-b dark:border-gray-700 shadow-sm sticky top-0 z-20\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-6xl mx-auto flex justify-between items-center px-4 py-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: \"http://localhost:3000/home\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-2xl font-extrabold bg-gradient-to-r from-purple-500 to-pink-500 text-transparent bg-clip-text tracking-wide\",\n                                children: \"Bingo CP\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                lineNumber: 693,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                            lineNumber: 692,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-4 border-l pl-6 ml-4 dark:border-gray-600\",\n                            children: [\n                                'Home',\n                                'ICPC Mode',\n                                'IOI Mode',\n                                'Help'\n                            ].map((label)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    href: \"\".concat(links[label]),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"cursor-pointer px-4 py-1 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-sm\",\n                                        children: label\n                                    }, label, false, {\n                                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                        lineNumber: 700,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                    lineNumber: 699,\n                                    columnNumber: 15\n                                }, this))\n                        }, void 0, false, {\n                            fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                            lineNumber: 697,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                    lineNumber: 691,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 690,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center mt-4\",\n                children: [\n                    !matchHasStarted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CountdownToStart, {\n                        startTime: matchStart\n                    }, void 0, false, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 724,\n                        columnNumber: 11\n                    }, this),\n                    matchHasEnded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-red-500\",\n                        children: \"Match has ended.\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 727,\n                        columnNumber: 11\n                    }, this),\n                    matchOngoing && match && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-green-500\",\n                        children: [\n                            \"Match ends in \",\n                            formatDuration(matchEnd.getTime() - Date.now())\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 730,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 722,\n                columnNumber: 7\n            }, this),\n            matchHasStarted ? loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Loading__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 739,\n                columnNumber: 9\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid \".concat(gridClasses[gridSize], \" gap-x-0 gap-y-4 justify-items-center mt-4 mx-70\"),\n                children: problems.map((problem, idx)=>{\n                    var _winner_keys;\n                    const key = \"\".concat(problem.contestId, \"-\").concat(problem.index);\n                    const solvedInfo = solved[key];\n                    var _problem_position, _solvedInfo_team;\n                    const ownerTeam = (_solvedInfo_team = solvedInfo === null || solvedInfo === void 0 ? void 0 : solvedInfo.team) !== null && _solvedInfo_team !== void 0 ? _solvedInfo_team : positionOwners[(_problem_position = problem.position) !== null && _problem_position !== void 0 ? _problem_position : idx]; // fallback by position\n                    const isWinningCell = winner === null || winner === void 0 ? void 0 : (_winner_keys = winner.keys) === null || _winner_keys === void 0 ? void 0 : _winner_keys.includes(key);\n                    // console.log('Rendering problem', key, 'solved by', solvedInfo?.team, 'teamColor:', teamColors[solvedInfo?.team]);\n                    const teamColor = ownerTeam ? teamColors[ownerTeam] || 'bg-gray-500 text-white' : 'bg-white hover:bg-blue-100 dark:bg-gray-800 dark:hover:bg-blue-900 text-gray-800 dark:text-gray-200';\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        onClick: ()=>window.open(\"https://codeforces.com/contest/\".concat(problem.contestId, \"/problem/\").concat(problem.index), '_blank'),\n                        // onDoubleClick={() => { // DONT forget to remove it later\n                        // // double click will locally mark for testing (toggleSquare) but disabled after lock\n                        // if (!matchLocked) toggleSquare(idx);\n                        // }}\n                        onMouseEnter: (e)=>{\n                            e.currentTarget.classList.add('scale-[1.04]', 'shadow-md');\n                        },\n                        onMouseLeave: (e)=>{\n                            e.currentTarget.classList.remove('scale-[1.04]', 'shadow-md');\n                        },\n                        className: \"w-36 h-24 p-2 flex flex-col justify-center items-center text-center rounded shadow cursor-pointer transition duration-200\\n                  \".concat(teamColor, \" \").concat(ownerTeam ? 'text-white' : '', \" \").concat(isWinningCell ? ' ring-4 ring-yellow-400 scale-[1.06]' : ''),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-semibold\",\n                                children: [\n                                    problem.rating,\n                                    \" - \",\n                                    problem.index\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                lineNumber: 774,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-xs mt-1\",\n                                children: problem.name\n                            }, void 0, false, {\n                                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                lineNumber: 777,\n                                columnNumber: 17\n                            }, this)\n                        ]\n                    }, \"\".concat(problem.contestId, \"-\").concat(problem.index), true, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 753,\n                        columnNumber: 15\n                    }, this);\n                })\n            }, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 741,\n                columnNumber: 9\n            }, this) : null,\n            showLog && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed bottom-4 left-1 w-72 max-h-[80vh] overflow-y-auto border rounded p-3 bg-white dark:bg-gray-900 shadow z-30\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold mb-2\",\n                        children: \"Solve Log\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 793,\n                        columnNumber: 11\n                    }, this),\n                    log.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm text-gray-500\",\n                        children: \"No solves yet\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 795,\n                        columnNumber: 13\n                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        className: \"text-sm space-y-2\",\n                        children: log.map((entry, idx)=>{\n                            const bgColor = teamColors[entry.team] || 'bg-gray-200 dark:bg-gray-700';\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                className: \"\".concat(bgColor, \" text-white px-3 py-2 rounded shadow-sm\"),\n                                children: entry.message\n                            }, idx, false, {\n                                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                                lineNumber: 801,\n                                columnNumber: 19\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                        lineNumber: 797,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 792,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>setShowLog((prev)=>!prev),\n                className: \"cursor-pointer fixed bottom-[calc(4rem+76vh)] left-4 px-3 py-1 bg-gray-300 dark:bg-gray-700 text-black dark:text-white rounded hover:bg-gray-400 dark:hover:bg-gray-600 transition z-40\",\n                children: showLog ? 'Hide Log' : 'Show Log'\n            }, void 0, false, {\n                fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n                lineNumber: 815,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\bingo-cp\\\\bingo-cp\\\\bingo-cp\\\\src\\\\app\\\\match\\\\[id]\\\\page.tsx\",\n        lineNumber: 683,\n        columnNumber: 5\n    }, this);\n}\n_s1(Home, \"60p0aQsvoS4RWGvVJRAFHHqRkHo=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useParams,\n        useWindowSize\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0Y2gvW2lkXS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDNEM7QUFDQTtBQUNSO0FBQ0U7QUFDUCxDQUFDLG9DQUFvQztBQU9wRSxNQUFNTSxhQUFxQztJQUN6Q0MsS0FBSztJQUNMQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxNQUFNO0FBQ1I7QUFFQSxNQUFNQyxRQUFnQztJQUNwQyxRQUFRO0lBQ1IsYUFBYTtJQUNiLFlBQVk7SUFDWixRQUFRO0FBQ1Y7QUFJQSxNQUFNQyxjQUFjO0lBQ2xCLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7QUFDTDtBQTRCQSxnREFBZ0Q7QUFDaEQsU0FBU0M7O0lBQ1AsTUFBTUMsV0FBVyxhQUFrQjtJQUNuQyxNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR25CLCtDQUFRQSxDQUFDO1FBQUVvQixPQUFPSCxXQUFXSSxPQUFPQyxVQUFVLEdBQUc7UUFBR0MsUUFBUU4sV0FBV0ksT0FBT0csV0FBVyxHQUFHO0lBQUU7SUFDdEh6QixnREFBU0E7bUNBQUM7WUFDUixJQUFJLENBQUNrQixVQUFVO1lBQ2YsU0FBU1E7Z0JBQ1BOLFFBQVE7b0JBQUVDLE9BQU9DLE9BQU9DLFVBQVU7b0JBQUVDLFFBQVFGLE9BQU9HLFdBQVc7Z0JBQUM7WUFDakU7WUFDQUgsT0FBT0ssZ0JBQWdCLENBQUMsVUFBVUQ7WUFDbENBO1lBQ0E7MkNBQU8sSUFBTUosT0FBT00sbUJBQW1CLENBQUMsVUFBVUY7O1FBQ3BEO2tDQUFHO1FBQUNSO0tBQVM7SUFDYixPQUFPQztBQUNUO0dBYlNGO0FBZVQsU0FBU1ksY0FBY0MsS0FBYSxFQUFFQyxJQUFhO0lBQ2pELCtCQUErQjtJQUMvQixJQUFJLE1BQTZCLElBQUksQ0FBRSxtQkFBa0JULE1BQUssR0FBSTtJQUNsRSxJQUFJVSxhQUFhQyxV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Q0FBNkI7Ozs7OztvQkFDMUNySCxJQUFJc0UsTUFBTSxLQUFLLGtCQUNkLDhEQUFDOUc7d0JBQUU2SixXQUFVO2tDQUF3Qjs7Ozs7NkNBRXJDLDhEQUFDc0Q7d0JBQUd0RCxXQUFVO2tDQUNYckgsSUFBSTFCLEdBQUcsQ0FBQyxDQUFDc0UsT0FBT2lIOzRCQUNmLE1BQU1lLFVBQVV6UCxVQUFVLENBQUN5SCxNQUFNSSxJQUFJLENBQUMsSUFBSTs0QkFDMUMscUJBQ0UsOERBQUM2SDtnQ0FFQ3hELFdBQVcsR0FBVyxPQUFSdUQsU0FBUTswQ0FFckJoSSxNQUFNUyxPQUFPOytCQUhUd0c7Ozs7O3dCQU1YOzs7Ozs7Ozs7Ozs7MEJBT1IsOERBQUNEO2dCQUNDTyxTQUFTLElBQU05SyxXQUFXaUUsQ0FBQUEsT0FBUSxDQUFDQTtnQkFDbkMrRCxXQUFVOzBCQUVUakksVUFBVSxhQUFhOzs7Ozs7Ozs7Ozs7QUFJaEM7SUE3cUJ3Qko7O1FBQ1BqRSxzREFBU0E7UUFzQkVlOzs7S0F2QkprRCIsInNvdXJjZXMiOlsiRDpcXGJpbmdvLWNwXFxiaW5nby1jcFxcYmluZ28tY3BcXHNyY1xcYXBwXFxtYXRjaFxcW2lkXVxccGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xyXG5pbXBvcnQgTG9hZGluZyBmcm9tICcuLi8uLi9Mb2FkaW5nJztcclxuaW1wb3J0IENvbmZldHRpIGZyb20gJ3JlYWN0LWNvbmZldHRpJztcclxuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnOyAvLyBhZGQgdG8gdG9wIGltcG9ydHMgaWYgbm90IHByZXNlbnRcclxuXHJcbi8vIGltcG9ydCB7IE1hdGNoU3RhdHVzIH0gZnJvbSBcIi4vTWF0Y2hTdGF0dXNcIjtcclxuaW1wb3J0IE1hdGNoQ3JlYXRpb25Gb3JtIGZyb20gJy4uLy4uL01hdGNoQ3JlYXRpb25Gb3JtJztcclxuaW1wb3J0IHsgTWF0Y2ggfSBmcm9tICcuLi8uLi90eXBlcy9tYXRjaCc7XHJcbmltcG9ydCBUZWFtc0Zvcm0gZnJvbSAnQC9hcHAvVGVhbXNGb3JtJztcclxuXHJcbmNvbnN0IHRlYW1Db2xvcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgcmVkOiAnYmctcmVkLTUwMCcsXHJcbiAgYmx1ZTogJ2JnLWJsdWUtNTAwJyxcclxuICBncmVlbjogJ2JnLWdyZWVuLTUwMCcsXHJcbiAgcHVycGxlOiAnYmctcHVycGxlLTUwMCcsXHJcbiAgb3JhbmdlOiAnYmctb3JhbmdlLTUwMCcsXHJcbiAgcGluazogJ2JnLXBpbmstNTAwJyxcclxuICB5ZWxsb3c6ICdiZy15ZWxsb3ctNTAwJyxcclxuICB0ZWFsOiAnYmctdGVhbC01MDAnLFxyXG59O1xyXG5cclxuY29uc3QgbGlua3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgXCJIb21lXCI6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvaG9tZScsXHJcbiAgXCJJQ1BDIE1vZGVcIjogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9jcmVhdGUtbWF0Y2gnLFxyXG4gIFwiSU9JIE1vZGVcIjogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9vaV9tb2RlJyxcclxuICBcIkhlbHBcIjogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9oZWxwJyxcclxufTtcclxuXHJcbnR5cGUgR3JpZFNpemUgPSAzIHwgNCB8IDUgfCA2OyAvLyBPbmx5IHRoZXNlIHZhbHVlcyBhcmUgYWxsb3dlZFxyXG5cclxuY29uc3QgZ3JpZENsYXNzZXMgPSB7XHJcbiAgMzogXCJncmlkLWNvbHMtMyBnYXAteC0wIGdhcC15LTQganVzdGlmeS1pdGVtcy1jZW50ZXIgbXQtNCBteC0xMzBcIixcclxuICA0OiBcImdyaWQtY29scy00IGdhcC14LTAgZ2FwLXktNCBqdXN0aWZ5LWl0ZW1zLWNlbnRlciBtdC00IG14LTExMFwiLFxyXG4gIDU6IFwiZ3JpZC1jb2xzLTUgZ2FwLXgtMCBnYXAteS00IGp1c3RpZnktaXRlbXMtY2VudGVyIG10LTQgbXgtOTBcIixcclxuICA2OiBcImdyaWQtY29scy02IGdhcC14LTAgZ2FwLXktNCBqdXN0aWZ5LWl0ZW1zLWNlbnRlciBtdC00IG14LTcwXCIsXHJcbn07XHJcblxyXG50eXBlIExvZ0VudHJ5ID0ge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICB0ZWFtOiBzdHJpbmc7XHJcbn1cclxuXHJcbnR5cGUgUHJvYmxlbSA9IHtcclxuICAvLyBpZDogbnVtYmVyO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICByYXRpbmc6IG51bWJlcjtcclxuICBjb250ZXN0SWQ6IG51bWJlcjtcclxuICBpbmRleDogc3RyaW5nO1xyXG4gIHBvc2l0aW9uPzogbnVtYmVyO1xyXG59O1xyXG50eXBlIFNvbHZlZEluZm8gPSB7XHJcbiAgdGVhbTogc3RyaW5nO1xyXG4gIFxyXG59O1xyXG5cclxudHlwZSBXaW5uZXIgPSB7XHJcbiAgdGVhbTogc3RyaW5nO1xyXG4gIHR5cGU6ICdyb3cnIHwgJ2NvbCcgfCAnZGlhZycgfCAnYW50aS1kaWFnJztcclxuICBpbmRleDogbnVtYmVyO1xyXG4gIGtleXM6IHN0cmluZ1tdOyAvLyBsaXN0IG9mIHByb2JsZW0ga2V5cyB0aGF0IGZvcm0gdGhlIHdpbm5pbmcgbGluZSwgZS5nLiBbXCIxMjM0LUFcIixcIjEyMzQtQlwiLC4uLl1cclxufSB8IG51bGw7XHJcblxyXG4vLyBzbWFsbCBsb2NhbCBob29rLCBhdm9pZHMgcmVhY3QtdXNlIGRlcGVuZGVuY3lcclxuZnVuY3Rpb24gdXNlV2luZG93U2l6ZSgpIHtcclxuICBjb25zdCBpc0NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xyXG4gIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IHVzZVN0YXRlKHsgd2lkdGg6IGlzQ2xpZW50ID8gd2luZG93LmlubmVyV2lkdGggOiAwLCBoZWlnaHQ6IGlzQ2xpZW50ID8gd2luZG93LmlubmVySGVpZ2h0IDogMCB9KTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0NsaWVudCkgcmV0dXJuO1xyXG4gICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XHJcbiAgICAgIHNldFNpemUoeyB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IH0pO1xyXG4gICAgfVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcclxuICAgIG9uUmVzaXplKCk7XHJcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcclxuICB9LCBbaXNDbGllbnRdKTtcclxuICByZXR1cm4gc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm90aWZ5QnJvd3Nlcih0aXRsZTogc3RyaW5nLCBib2R5Pzogc3RyaW5nKSB7XHJcbiAgLy8gUmVxdWVzdCBwZXJtaXNzaW9uIGlmIG5lZWRlZFxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykpIHJldHVybjtcclxuICBpZiAoTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdncmFudGVkJykge1xyXG4gICAgdHJ5IHsgbmV3IE5vdGlmaWNhdGlvbih0aXRsZSwgeyBib2R5IH0pOyB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gJ2RlbmllZCcpIHtcclxuICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpLnRoZW4ocGVybWlzc2lvbiA9PiB7XHJcbiAgICAgIGlmIChwZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgICB0cnkgeyBuZXcgTm90aWZpY2F0aW9uKHRpdGxlLCB7IGJvZHkgfSk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gbm9ybWFsaXplL2RlZHVwZSBzZXJ2ZXIgcHJvYmxlbXM6IHByZWZlciBwb3NpdGlvbiwgZmFsbCBiYWNrIHRvIGNvbnRlc3RJZC1pbmRleFxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9ibGVtc0Zyb21TZXJ2ZXIocmF3OiBhbnlbXSkge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShyYXcpKSByZXR1cm4gW107XHJcblxyXG4gIC8vIGtlZXAgb25seSBhY3RpdmUgKGRlZmVuc2l2ZSlcclxuICBjb25zdCBhY3RpdmUgPSByYXcuZmlsdGVyKHAgPT4gcCAmJiBwLmFjdGl2ZSAhPT0gZmFsc2UpO1xyXG5cclxuICAvLyBJZiBwcm9ibGVtcyBoYXZlIGBwb3NpdGlvbmAsIHVzZSBhIE1hcCBrZXllZCBieSBwb3NpdGlvbiAoa2VlcHMgc2xvdCBjb3VudCBzdGFibGUpXHJcbiAgY29uc3QgaGFzUG9zaXRpb24gPSBhY3RpdmUuZXZlcnkocCA9PiB0eXBlb2YgcC5wb3NpdGlvbiA9PT0gJ251bWJlcicpO1xyXG5cclxuICBpZiAoaGFzUG9zaXRpb24pIHtcclxuICAgIGNvbnN0IGJ5UG9zID0gbmV3IE1hcDxudW1iZXIsIGFueT4oKTtcclxuICAgIGZvciAoY29uc3QgcCBvZiBhY3RpdmUpIHtcclxuICAgICAgY29uc3QgcG9zID0gcC5wb3NpdGlvbiBhcyBudW1iZXI7XHJcbiAgICAgIC8vIGlmIGR1cGxpY2F0ZXMgZm9yIHNhbWUgcG9zaXRpb24gZXhpc3QsIGtlZXAgdGhlIGZpcnN0IG9uZSAoc2VydmVyIHNob3VsZCBhdm9pZCB0aGlzKVxyXG4gICAgICBpZiAoIWJ5UG9zLmhhcyhwb3MpKSBieVBvcy5zZXQocG9zLCBwKTtcclxuICAgICAgLy8gb3B0aW9uYWxseTogaWYgeW91IHdhbnQgbmV3ZXN0OiBhbHdheXMgb3ZlcndyaXRlIGJ5UG9zLnNldChwb3MsIHApXHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGUgYXJyYXkgb3JkZXJlZCBieSBwb3NpdGlvbiAoZmlsbCBnYXBzIGlmIHlvdSB3YW50IHdpdGggbnVsbHMg4oCUIHdlIHNvcnQpXHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieVBvcy5lbnRyaWVzKCkpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcclxuICAgICAgLm1hcCgoW18sIHBdKSA9PiBwKTtcclxuICB9XHJcblxyXG4gIC8vIEZhbGxiYWNrOiBkZWR1cGUgYnkgY29udGVzdElkLWluZGV4IGtleSBhbmQgcHJlc2VydmUgc2VydmVyIG9yZGVyXHJcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gIGNvbnN0IHJlc3VsdDogYW55W10gPSBbXTtcclxuICBmb3IgKGNvbnN0IHAgb2YgYWN0aXZlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHtwLmNvbnRlc3RJZH0tJHtwLmluZGV4fWA7XHJcbiAgICBpZiAoIXNlZW4uaGFzKGtleSkpIHtcclxuICAgICAgc2Vlbi5hZGQoa2V5KTtcclxuICAgICAgcmVzdWx0LnB1c2gocCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XHJcbiAgY29uc3QgcGFyYW1zID0gdXNlUGFyYW1zKCk7XHJcbiAgICBjb25zdCByYXdJZCA9IHBhcmFtcz8uaWQ7XHJcbiAgICBjb25zdCBpZCA9IEFycmF5LmlzQXJyYXkocmF3SWQpID8gcmF3SWRbMF0gOiByYXdJZDsgLy8gaWQgaXMgbm93IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gIFxyXG4gIC8vIGNvbnN0IFtpc0RhcmtNb2RlLCBzZXRJc0RhcmtNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbc2hvd0xvZywgc2V0U2hvd0xvZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBbY3VycmVudFRlYW0sIHNldEN1cnJlbnRUZWFtXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IFtwcm9ibGVtcywgc2V0UHJvYmxlbXNdID0gdXNlU3RhdGU8UHJvYmxlbVtdPihbXSk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2dyaWRTaXplLCBzZXRncmlkU2l6ZV0gPSB1c2VTdGF0ZTxHcmlkU2l6ZT4oNSk7XHJcbiAgY29uc3QgW3NvbHZlZCwgc2V0U29sdmVkXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIFNvbHZlZEluZm8+Pih7fSk7XHJcbiAgY29uc3QgW2xvZywgc2V0TG9nXSA9IHVzZVN0YXRlPExvZ0VudHJ5W10+KFtdKTtcclxuICBjb25zdCBbbWF0Y2gsIHNldE1hdGNoXSA9IHVzZVN0YXRlPE1hdGNoIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IHVzZVN0YXRlKG5ldyBEYXRlKCkpO1xyXG4gIFxyXG4gIC8vIHdpbiAvIGxvY2sgLyBjb25mZXR0aSBzdGF0ZVxyXG4gIGNvbnN0IFt3aW5uZXIsIHNldFdpbm5lcl0gPSB1c2VTdGF0ZTxXaW5uZXI+KG51bGwpO1xyXG4gIGNvbnN0IFttYXRjaExvY2tlZCwgc2V0TWF0Y2hMb2NrZWRdID0gdXNlU3RhdGUoZmFsc2UpOyAvLyBwcmV2ZW50cyBmdXJ0aGVyIG1hcmtpbmcvcG9sbGluZyBhZnRlciB3aW5cclxuICBjb25zdCBbY29uZmV0dGlBY3RpdmUsIHNldENvbmZldHRpQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcG9zaXRpb25Pd25lcnMsIHNldFBvc2l0aW9uT3duZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxudW1iZXIsIHN0cmluZz4+KHt9KTtcclxuXHJcbiAgICAvLyB3aW5kb3cgc2l6ZSAodXNlIHRoZSBsb2NhbCBob29rKVxyXG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdXNlV2luZG93U2l6ZSgpO1xyXG5cclxuLy8gICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGUoXCJIb21lXCIpO1xyXG5cclxuICBjb25zdCBub3RpZmllZFJlZiA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKTtcclxuXHJcbiAgZnVuY3Rpb24gcGVyc2lzdE5vdGlmaWVkKG1hdGNoSWQ6IHN0cmluZykge1xyXG4gICAgY29uc3Qga2V5ID0gYG5vdGlmaWVkXyR7bWF0Y2hJZH1gO1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5vdGlmaWVkUmVmLmN1cnJlbnQpKSk7XHJcbiAgICB9IGNhdGNoIHt9XHJcbiAgfVxyXG5cclxuICAvLyByZXN0b3JlIGZyb20gbG9jYWxTdG9yYWdlIHdoZW4gbWF0Y2ggbG9hZHMgKG9uY2UgcGVyIG1hdGNoKVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hdGNoPy5pZCkgcmV0dXJuO1xyXG4gICAgY29uc3Qga2V5ID0gYG5vdGlmaWVkXyR7bWF0Y2guaWR9YDtcclxuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBhcnIgPSByYXcgPyBKU09OLnBhcnNlKHJhdykgOiBbXTtcclxuICAgICAgbm90aWZpZWRSZWYuY3VycmVudCA9IG5ldyBTZXQoYXJyKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBub3RpZmllZFJlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gIH0sIFttYXRjaD8uaWRdKTtcclxuXHJcblxyXG4gIC8vIC0tLSBGZXRjaCBtYXRjaCBieSBpZCBvbiBtb3VudCAvIHdoZW4gaWQgY2hhbmdlcyAtLS1cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpZCkgcmV0dXJuO1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBmZXRjaE1hdGNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2dldE1hdGNoP21hdGNoSWQ9JHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWApO1xyXG4gICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbWF0Y2gnLCBhd2FpdCByZXMudGV4dCgpKTtcclxuICAgICAgICAgIHNldE1hdGNoKG51bGwpO1xyXG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgIC8vIElmIHlvdXIgQVBJIHJldHVybnMgeyBtYXRjaCB9IHVzZSBkYXRhLm1hdGNoLCBvdGhlcndpc2UgZGF0YSAoYWRqdXN0IGlmIG5lZWRlZClcclxuICAgICAgICBjb25zdCBtYXRjaE9iaiA9IGRhdGEubWF0Y2ggPz8gZGF0YTtcclxuICAgICAgICBzZXRNYXRjaChtYXRjaE9iaik7XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIHNvbHZlZCBtYXAgKyBsb2cgZnJvbSByZXR1cm5lZCBtYXRjaCdzIHNvbHZlTG9nIChzbyBwYWdlIHNob3dzIGZpbmFsIHJlc3VsdHMgaWYgbWF0Y2ggYWxyZWFkeSBlbmRlZClcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNvbHZlZE1hcDogUmVjb3JkPG51bWJlciwgU29sdmVkSW5mbz4gPSB7fTtcclxuICAgICAgICBjb25zdCBuZXdMb2dFbnRyaWVzOiBMb2dFbnRyeVtdID0gW107XHJcbiAgICAgICAgY29uc3QgcG9zT3duZXJzOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge307XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJGU1M6IFwiLCBtYXRjaE9iai50ZWFtcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRlYW1zRnJvbVNlcnZlciA9IG1hdGNoT2JqLnRlYW1zID8/IFtdO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibXlzOiBcIiwgbWF0Y2hPYmouc29sdmVMb2cpO1xyXG5cclxuICAgICAgICAobWF0Y2hPYmouc29sdmVMb2cgPz8gW10pLmZvckVhY2goKGVudHJ5OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7ZW50cnkuY29udGVzdElkfS0ke2VudHJ5LmluZGV4fWA7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGlzcGxheU5hbWUsIHRlYW1LZXkgfSA9IHJlc29sdmVUZWFtRGlzcGxheUFuZEtleShlbnRyeS50ZWFtLCB0ZWFtc0Zyb21TZXJ2ZXIpO1xyXG4gICAgICAgICAgICBzb2x2ZWRNYXBbZW50cnkucHJvYmxlbS5wb3NpdGlvbl0gPSB7XHJcbiAgICAgICAgICAgICAgdGVhbTogdGVhbUtleSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gSWYgc29sdmVMb2cgaW5jbHVkZXMgdGhlIHByb2JsZW0gcmVsYXRpb24gYW5kIGl0IGhhcyBhIHBvc2l0aW9uLCBtYXAgcG9zaXRpb24gLT4gb3duZXJcclxuICAgICAgICAgICAgaWYgKGVudHJ5LnByb2JsZW0gJiYgdHlwZW9mIGVudHJ5LnByb2JsZW0ucG9zaXRpb24gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgcG9zT3duZXJzW2VudHJ5LnByb2JsZW0ucG9zaXRpb25dID0gdGVhbUtleTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdXNlIHByb2JsZW0gbmFtZSBpZiBpbmNsdWRlZCBieSBBUEksIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gaW5kZXhcclxuICAgICAgICAgICAgY29uc3QgcHJvYmxlbU5hbWUgPSBlbnRyeS5wcm9ibGVtPy5uYW1lID8/IGBQcm9ibGVtICR7ZW50cnkuaW5kZXh9YDtcclxuICAgICAgICAgICAgY29uc3QgY29udGVzdEFuZEluZGV4ID0gYCR7ZW50cnkuY29udGVzdElkfSR7ZW50cnkuaW5kZXh9YDtcclxuICAgICAgICAgICAgbmV3TG9nRW50cmllcy5wdXNoKHtcclxuICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogYCR7ZGlzcGxheU5hbWV9IHNvbHZlZCAke3Byb2JsZW1OYW1lfSAoJHtjb250ZXN0QW5kSW5kZXh9KWAsXHJcbiAgICAgICAgICAgICAgdGVhbTogdGVhbUtleSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIG5ld0xvZ0VudHJpZXMucHVzaCh7XHJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2U6IGAke2VudHJ5LnRlYW19IHNvbHZlZCAke3Byb2JsZW1OYW1lfSAoJHtjb250ZXN0QW5kSW5kZXh9KWAsXHJcbiAgICAgICAgICAgIC8vIHRlYW06IGVudHJ5LnRlYW0udG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJNUzogXCIsIHNvbHZlZE1hcCk7XHJcbiAgICAgICAgc2V0UG9zaXRpb25Pd25lcnMocG9zT3duZXJzKTsgIC8vIDwtLSBzZXQgc3RhdGVcclxuXHJcbiAgICAgICAgLy8gbWVyZ2Ugd2l0aCBhbnkgZXhpc3RpbmcgbG9nIChrZWVwIG5ld2VzdCBmaXJzdCkgYnV0IGF2b2lkIGR1cGxpY2F0ZXNcclxuICAgICAgICBzZXRMb2cocHJldiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkID0gWy4uLm5ld0xvZ0VudHJpZXMsIC4uLnByZXZdO1xyXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVNYXAgPSBuZXcgTWFwPHN0cmluZywgTG9nRW50cnk+KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBjb21iaW5lZCkge1xyXG4gICAgICAgICAgICAgIGlmICghdW5pcXVlTWFwLmhhcyhlLmtleSkpIHVuaXF1ZU1hcC5zZXQoZS5rZXksIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVNYXAudmFsdWVzKCkpLnNsaWNlKDAsIDEwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRTb2x2ZWQoc29sdmVkTWFwKTtcclxuICAgICAgICAvLyBBRlRFUiBzZXRMb2coLi4uKSBpbnNpZGUgdGhlIGluaXRpYWwgZmV0Y2ggdHJ5IGJsb2NrOlxyXG4gICAgICAgIC8vIGlmIChtYXRjaE9iaj8uaWQpIHtcclxuICAgICAgICAvLyAgIC8vIE1hcmsgaW5pdGlhbCBoaXN0b3JpYyBtZXNzYWdlcyBhcyBub3RpZmllZCBzbyBuZXcgdGFiIHdvbid0IHJlLW5vdGlmeSB0aGVtXHJcbiAgICAgICAgLy8gICBuZXdMb2dFbnRyaWVzLmZvckVhY2gobmUgPT4gbm90aWZpZWRSZWYuY3VycmVudC5hZGQobmUubWVzc2FnZSkpO1xyXG4gICAgICAgIC8vICAgcGVyc2lzdE5vdGlmaWVkKG1hdGNoT2JqLmlkKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBkb24ndCBjcmFzaCBpZiBzaGFwZSBpcyB1bmV4cGVjdGVkXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgYnVpbGQgc29sdmVkL2xvZyBmcm9tIG1hdGNoT2JqLnNvbHZlTG9nJywgZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWF0Y2gnLCBlcnIpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZldGNoTWF0Y2goKTtcclxuICB9LCBbaWRdKTtcclxuXHJcblxyXG4gIC8vIGhlbHBlciB0byBtYXAgYW4gZW50cnkudGVhbSAod2hpY2ggbWlnaHQgYmUgY29sb3Igb3IgbmFtZSkgdG8gZGlzcGxheU5hbWUgYW5kIGNvbG9yIGtleVxyXG4gIC8vIGhlbHBlciB0byBtYXAgYW4gZW50cnkudGVhbSAod2hpY2ggbWlnaHQgYmUgY29sb3Igb3IgbmFtZSkgdG8gZGlzcGxheU5hbWUgYW5kIGNvbG9yIGtleVxyXG4gIC8vIGhlbHBlciB0byBtYXAgYW4gZW50cnkudGVhbSAod2hpY2ggbWlnaHQgYmUgY29sb3Igb3IgbmFtZSkgdG8gZGlzcGxheU5hbWUgYW5kIGNvbG9yIGtleVxyXG4gIGZ1bmN0aW9uIHJlc29sdmVUZWFtRGlzcGxheUFuZEtleSh0ZWFtSWRlbnRpZmllcjogc3RyaW5nIHwgdW5kZWZpbmVkLCB0ZWFtc0xpc3RQYXJhbT86IGFueVtdKSB7XHJcbiAgICAvLyBwcmVmZXIgZXhwbGljaXQgbGlzdCBwYXNzZWQgaW47IGZhbGxiYWNrIHRvIGN1cnJlbnQgbWF0Y2ggc3RhdGVcclxuICAgIGNvbnN0IHRlYW1zTGlzdCA9IHRlYW1zTGlzdFBhcmFtID8/IChtYXRjaD8udGVhbXMgPz8gW10pO1xyXG4gICAgaWYgKCF0ZWFtSWRlbnRpZmllcikgcmV0dXJuIHsgZGlzcGxheU5hbWU6ICdVbmtub3duJywgdGVhbUtleTogJ3Vua25vd24nIH07XHJcblxyXG4gICAgY29uc3Qgc2VhcmNoID0gdGVhbUlkZW50aWZpZXIudG9Mb3dlckNhc2UoKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiVGVhbXNTU1NTOiBcIiwgdGVhbXNMaXN0KTtcclxuICAgIGNvbnN0IHRlYW1PYmogPSB0ZWFtc0xpc3QuZmluZCh0ID0+XHJcbiAgICAgICh0LmNvbG9yID8/ICcnKS50b0xvd2VyQ2FzZSgpID09PSBzZWFyY2ggfHwgKHQubmFtZSA/PyAnJykudG9Mb3dlckNhc2UoKSA9PT0gc2VhcmNoXHJcbiAgICApO1xyXG4gICAgLy8gY29uc29sZS5sb2coJ1RFQU1TOiAnLCBtYXRjaD8udGVhbXMpO1xyXG5cclxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gdGVhbU9iaj8ubmFtZSA/PyB0ZWFtSWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHRlYW1LZXkgPSAodGVhbU9iaj8uY29sb3IgPz8gdGVhbUlkZW50aWZpZXIgPz8gJ3Vua25vd24nKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIHJldHVybiB7IGRpc3BsYXlOYW1lLCB0ZWFtS2V5IH07XHJcbiAgfVxyXG5cclxuXHJcblxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG1hdGNoPy50ZWFtcz8ubGVuZ3RoICYmICFjdXJyZW50VGVhbSkge1xyXG4gICAgICAgIC8vIHN0b3JlIGNvbG9yIGtleSBhcyBjdXJyZW50VGVhbSAocmVjb21tZW5kZWQpXHJcbiAgICAgICAgc2V0Q3VycmVudFRlYW0obWF0Y2gudGVhbXNbMF0uY29sb3IpOyBcclxuICAgICAgICAvLyBPUiBzZXRDdXJyZW50VGVhbShtYXRjaC50ZWFtc1swXS5uYW1lKSBpZiB5b3UgcHJlZmVyIHN0b3JpbmcgZGlzcGxheSBuYW1lc1xyXG4gICAgfVxyXG4gICAgfSwgW21hdGNoXSk7XHJcblxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG1hdGNoTG9ja2VkKSByZXR1cm47IC8vIGRvbid0IHBvbGwvbWVyZ2UgdXBkYXRlcyBhZnRlciBhIHdpbi9sb2NrXHJcbiAgICBpZiAoIW1hdGNoPy5pZCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IG1hdGNoU3RhcnQgPSBuZXcgRGF0ZShtYXRjaC5zdGFydFRpbWUpO1xyXG4gICAgY29uc3QgbWF0Y2hFbmQgPSBuZXcgRGF0ZShtYXRjaFN0YXJ0LmdldFRpbWUoKSArIG1hdGNoLmR1cmF0aW9uTWludXRlcyAqIDYwICogMTAwMCk7XHJcblxyXG4gICAgY29uc3QgZmV0Y2hQb2xsID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBpZiAobm93IDwgbWF0Y2hTdGFydCB8fCBub3cgPiBtYXRjaEVuZCkge1xyXG4gICAgICAgIC8vIERvbid0IHBvbGwgb3V0c2lkZSBtYXRjaCB0aW1lXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcG9sbFJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3BvbGwtc3VibWlzc2lvbnMnLCB7XHJcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtYXRjaElkOiBtYXRjaC5pZCB9KSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwb2xsRGF0YSA9IGF3YWl0IHBvbGxSZXMuanNvbigpO1xyXG5cclxuICAgICAgICBpZiAocG9sbERhdGEudXBkYXRlZCAmJiBwb2xsRGF0YS5tYXRjaCkge1xyXG4gICAgICAgICAgc2V0TWF0Y2gocG9sbERhdGEubWF0Y2gpO1xyXG5cclxuICAgICAgICAgIC8vIEJ1aWxkIHNvbHZlZCBtYXBcclxuICAgICAgICAgIGNvbnN0IHNvbHZlZE1hcDogUmVjb3JkPHN0cmluZywgU29sdmVkSW5mbz4gPSB7fTtcclxuICAgICAgICAgIGNvbnN0IG5ld0xvZ0VudHJpZXM6IExvZ0VudHJ5W10gPSBbXTtcclxuICAgICAgICAgIGNvbnN0IHBvc093bmVyczogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHt9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHByb2JsZW1VcGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCB7IG5hbWU/OiBzdHJpbmc7IHJhdGluZz86IG51bWJlcjsgY29udGVzdElkPzogbnVtYmVyOyBpbmRleD86c3RyaW5nIH0+ID0ge307XHJcblxyXG4gICAgICAgICAgY29uc3QgdGVhbXNGcm9tU2VydmVyID0gcG9sbERhdGEubWF0Y2g/LnRlYW1zID8/IFtdO1xyXG4gICAgICAgICAgcG9sbERhdGEubWF0Y2guc29sdmVMb2cuZm9yRWFjaCgoZW50cnk6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtlbnRyeS5jb250ZXN0SWR9LSR7ZW50cnkuaW5kZXh9YDtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSZXNTIDpcIiwgdGVhbXNGcm9tU2VydmVyKTtcclxuICAgICAgICAgICAgY29uc3QgeyBkaXNwbGF5TmFtZSwgdGVhbUtleSB9ID0gcmVzb2x2ZVRlYW1EaXNwbGF5QW5kS2V5KGVudHJ5LnRlYW0sIHRlYW1zRnJvbVNlcnZlcik7XHJcbiAgICAgICAgICAgIHNvbHZlZE1hcFtrZXldID0ge1xyXG4gICAgICAgICAgICAgIHRlYW06IHRlYW1LZXksIC8vIHN0b3JlIGNvbG9yIGtleSBmb3IgVUlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNvbHZlTG9nIGluY2x1ZGVzIHRoZSBwcm9ibGVtIHJlbGF0aW9uIGFuZCBpdCBoYXMgYSBwb3NpdGlvbiwgbWFwIHBvc2l0aW9uIC0+IG93bmVyXHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5wcm9ibGVtICYmIHR5cGVvZiBlbnRyeS5wcm9ibGVtLnBvc2l0aW9uID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgIHBvc093bmVyc1tlbnRyeS5wcm9ibGVtLnBvc2l0aW9uXSA9IHRlYW1LZXk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5wcm9ibGVtKSB7XHJcbiAgICAgICAgICAgICAgcHJvYmxlbVVwZGF0ZXNba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGVudHJ5LnByb2JsZW0ubmFtZSA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByYXRpbmc6IGVudHJ5LnByb2JsZW0ucmF0aW5nID8/IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGNvbnRlc3RJZDogZW50cnkuY29udGVzdElkLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBuZXcgbG9nIGVudHJpZXNcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2JsZW1OYW1lID0gZW50cnkucHJvYmxlbT8ubmFtZSA/PyBgUHJvYmxlbSAke2VudHJ5LmluZGV4fWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlc3RBbmRJbmRleCA9IGAke2VudHJ5LmNvbnRlc3RJZH0ke2VudHJ5LmluZGV4fWA7XHJcbiAgICAgICAgICAgIG5ld0xvZ0VudHJpZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2Rpc3BsYXlOYW1lfSBzb2x2ZWQgJHtwcm9ibGVtTmFtZX0gKCR7Y29udGVzdEFuZEluZGV4fSlgLFxyXG4gICAgICAgICAgICAgIHRlYW06IHRlYW1LZXksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgc2V0U29sdmVkKHNvbHZlZE1hcCk7XHJcbiAgICAgICAgICBzZXRQb3NpdGlvbk93bmVycyhwb3NPd25lcnMpOyAgLy8gPC0tIHNldCBzdGF0ZVxyXG5cclxuICAgICAgICAgIGlmIChwb2xsRGF0YS5tYXRjaD8ucHJvYmxlbXMgJiYgQXJyYXkuaXNBcnJheShwb2xsRGF0YS5tYXRjaC5wcm9ibGVtcykpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVByb2JsZW1zRnJvbVNlcnZlcihwb2xsRGF0YS5tYXRjaC5wcm9ibGVtcyk7XHJcbiAgICAgICAgICAgIHNldFByb2JsZW1zKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhwcm9ibGVtVXBkYXRlcykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzZXRQcm9ibGVtcyhwcmV2ID0+XHJcbiAgICAgICAgICAgICAgcHJldi5tYXAocCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gYCR7cC5jb250ZXN0SWR9LSR7cC5pbmRleH1gO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkID0gcHJvYmxlbVVwZGF0ZXNba107XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVwZCkgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgICAgICAvLyBvbmx5IG92ZXJyaWRlIGZpZWxkcyBwcm92aWRlZCBieSBzZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgbmFtZTogdXBkLm5hbWUgPz8gcC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICByYXRpbmc6IHVwZC5yYXRpbmcgPz8gcC5yYXRpbmcsXHJcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnRlc3RJZC9pbmRleCBub3JtYWxseSB1bmNoYW5nZWQsIGJ1dCBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzOlxyXG4gICAgICAgICAgICAgICAgICBjb250ZXN0SWQ6IHVwZC5jb250ZXN0SWQgPz8gcC5jb250ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICAgIGluZGV4OiB1cGQuaW5kZXggPz8gcC5pbmRleCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB0aGVuIHB1Ymxpc2ggb3duZXJzL3NvbHZlZCBzbyBVSSBjYW4gbWFwIGJ5IHByb2JsZW0ucG9zaXRpb24gcmVsaWFibHlcclxuICAgICAgICAgIHNldFNvbHZlZChzb2x2ZWRNYXApO1xyXG4gICAgICAgICAgc2V0UG9zaXRpb25Pd25lcnMocG9zT3duZXJzKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgbG9nOiBlaXRoZXIgcmVwbGFjZSBlbnRpcmVseSBvciBtZXJnZSB3aXRoIHByZXZpb3VzIGxvZ1xyXG4gICAgICAgICAgLy8gSGVyZSwganVzdCByZXBsYWNlIHdpdGggbGF0ZXN0IGZyb20gREIgKG9yIG1lcmdlIGlmIHlvdSB3YW50KVxyXG4gICAgICAgICAgc2V0TG9nKHByZXZMb2cgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IFsuLi5uZXdMb2dFbnRyaWVzLCAuLi5wcmV2TG9nXTtcclxuICAgICAgICAgICAgY29uc3QgdW5pcXVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIExvZ0VudHJ5PigpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGNvbWJpbmVkKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCF1bmlxdWVNYXAuaGFzKGVudHJ5LmtleSkpIHVuaXF1ZU1hcC5zZXQoZW50cnkua2V5LCBlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGVkdXBlZCA9IEFycmF5LmZyb20odW5pcXVlTWFwLnZhbHVlcygpKS5zbGljZSgwLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBub3RpZnkgb25seSBmb3IgbWVzc2FnZXMgbm90IGluIHByZXZMb2dcclxuICAgICAgICAgICAgY29uc3QgcHJldk1lc3NhZ2VzID0gbmV3IFNldChwcmV2TG9nLm1hcCh4ID0+IHgubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICBuZXdMb2dFbnRyaWVzLmZvckVhY2gobmUgPT4ge1xyXG4gICAgICAgICAgICAgIGlmICghcHJldk1lc3NhZ2VzLmhhcyhuZS5tZXNzYWdlKSAmJiAhbm90aWZpZWRSZWYuY3VycmVudC5oYXMobmUubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNlbmQgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBub3RpZnlCcm93c2VyKFwiU29sdmUgcmVwb3J0ZWRcIiwgbmUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdGlmaWVkIGFuZCBwZXJzaXN0XHJcbiAgICAgICAgICAgICAgICBub3RpZmllZFJlZi5jdXJyZW50LmFkZChuZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBwZXJzaXN0IHVwZGF0ZWQgbm90aWZpZWQgc2V0XHJcbiAgICAgICAgICAgIGlmIChwb2xsRGF0YS5tYXRjaD8uaWQpIHBlcnNpc3ROb3RpZmllZChwb2xsRGF0YS5tYXRjaC5pZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVkdXBlZDtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BvbGxpbmcgc3VibWlzc2lvbnMgZmFpbGVkJywgZXJyKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmZXRjaFBvbGwoKTtcclxuXHJcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGZldGNoUG9sbCwgMTAwMDApOyAvLyBSRU1FTUJFUiBUTyBDSEFOR0UgVE8gMTVTXHJcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICB9LCBbbWF0Y2g/LmlkLCBtYXRjaD8uc3RhcnRUaW1lLCBtYXRjaD8uZHVyYXRpb25NaW51dGVzLCBtYXRjaExvY2tlZF0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIHNldE5vdyhuZXcgRGF0ZSgpKVxyXG4gICAgfSwgMTAwMClcclxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICB9LCBbXSk7XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWF0Y2gpIHJldHVybjtcclxuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUobWF0Y2guc3RhcnRUaW1lKTtcclxuICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHN0YXJ0LmdldFRpbWUoKSArIG1hdGNoLmR1cmF0aW9uTWludXRlcyAqIDYwICogMTAwMCk7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGlmIChub3cgPj0gZW5kKSB7XHJcbiAgICAgICAgc2V0TWF0Y2hMb2NrZWQodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwgW21hdGNoXSk7XHJcblxyXG4gICAgLy8gRmV0Y2ggcHJvYmxlbXMgd2hlbiBtYXRjaCBjaGFuZ2VzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWF0Y2gpIHJldHVybjtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiZm9yIGNyeWluZyBvdXQgbG91ZDogXCIsIG1hdGNoLnByb2JsZW1zKVxyXG4gICAgY29uc3QgbGVuID0gbWF0Y2gucHJvYmxlbXM/Lmxlbmd0aCA/PyAwO1xyXG4gICAgaWYobGVuID09PSAzNikgc2V0Z3JpZFNpemUoNiBhcyBHcmlkU2l6ZSk7XHJcbiAgICBlbHNlIGlmKGxlbiA9PT0gMjUpIHNldGdyaWRTaXplKDUgYXMgR3JpZFNpemUpO1xyXG4gICAgZWxzZSBpZihsZW4gPT09IDE2KSBzZXRncmlkU2l6ZSg0IGFzIEdyaWRTaXplKTtcclxuICAgIGVsc2Ugc2V0Z3JpZFNpemUoMyBhcyBHcmlkU2l6ZSk7XHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBpbmNvbWluZyBwcm9ibGVtcyB0byBhdm9pZCBkdXBsaWNhdGVzIC8gdW5leHBlY3RlZCBpbmNyZWFzZXNcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQcm9ibGVtc0Zyb21TZXJ2ZXIobWF0Y2gucHJvYmxlbXMgfHwgW10pO1xyXG4gICAgc2V0UHJvYmxlbXMobm9ybWFsaXplZCk7IC8vIHByb2JsZW1zIG5vdyBoYXZlIGNvbnRlc3RJZCwgaW5kZXgsIG5hbWUsIHJhdGluZywgcG9zaXRpb25cclxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gIH0sIFttYXRjaF0pO1xyXG4gIGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uKG1zOiBudW1iZXIpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiTnVtOiBcIiwgbXMpXHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIm1hdGNoLnN0YXJ0VGltZTpcIiwgbWF0Y2g/LnN0YXJ0VGltZSk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcInN0YXJ0OiBcIiwgRGF0ZS5ub3coKSlcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiTk9PT09PT09PT09PT09PT09PTFNES0ZKTFNES0ZITEFLU0hGTEtTREpGTEtIU0RMRktKTE5PTk9OT05PTk9OXCIpXHJcbiAgICBjb25zdCB0b3RhbFNlY29uZHMgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1zIC8gMTAwMCkpO1xyXG4gICAgY29uc3QgaG91cnMgPSBTdHJpbmcoTWF0aC5mbG9vcih0b3RhbFNlY29uZHMgLyAzNjAwKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgY29uc3QgbWludXRlcyA9IFN0cmluZyhNYXRoLmZsb29yKCh0b3RhbFNlY29uZHMgJSAzNjAwKSAvIDYwKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgY29uc3Qgc2Vjb25kcyA9IFN0cmluZyh0b3RhbFNlY29uZHMgJSA2MCkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgcmV0dXJuIGAke2hvdXJzfToke21pbnV0ZXN9OiR7c2Vjb25kc31gO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmb3JtYXRDb3VudGRvd24obXM6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBpZiAobXMgPD0gMCkgcmV0dXJuIFwiMDA6MDA6MDBcIjtcclxuICAgIGNvbnN0IHRvdGFsU2Vjb25kcyA9IE1hdGguZmxvb3IobXMgLyAxMDAwKTtcclxuICAgIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcih0b3RhbFNlY29uZHMgLyAzNjAwKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcclxuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh0b3RhbFNlY29uZHMgJSAzNjAwKSAvIDYwKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcclxuICAgIGNvbnN0IHNlY29uZHMgPSAodG90YWxTZWNvbmRzICUgNjApLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgcmV0dXJuIGAke2hvdXJzfToke21pbnV0ZXN9OiR7c2Vjb25kc31gO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIENvdW50ZG93blRvU3RhcnQoeyBzdGFydFRpbWUgfTogeyBzdGFydFRpbWU6IERhdGUgfSkge1xyXG4gICAgY29uc3QgW3RpbWVMZWZ0LCBzZXRUaW1lTGVmdF0gPSB1c2VTdGF0ZSgoKSA9PiBzdGFydFRpbWUuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgc2V0VGltZUxlZnQoc3RhcnRUaW1lLmdldFRpbWUoKSAtIERhdGUubm93KCkpO1xyXG4gICAgICB9LCAxMDAwKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgIH0sIFtzdGFydFRpbWVdKTtcclxuXHJcbiAgICBpZiAodGltZUxlZnQgPD0gMCkge1xyXG4gICAgICByZXR1cm4gPHA+TWF0Y2ggaXMgc3RhcnRpbmcgbm93Li4uPC9wPjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcih0aW1lTGVmdCAvIDYwMDAwKTtcclxuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKCh0aW1lTGVmdCAlIDYwMDAwKSAvIDEwMDApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteWVsbG93LTUwMFwiPlxyXG4gICAgICAgIE1hdGNoIHN0YXJ0cyBpbiB7Zm9ybWF0RHVyYXRpb24oc3RhcnRUaW1lLmdldFRpbWUoKSAtIERhdGUubm93KCkpfVxyXG4gICAgICA8L3A+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgLy8gICBjb25zdCB0aGVtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0aGVtZScpO1xyXG4gIC8vICAgY29uc3QgcHJlZmVyc0RhcmsgPSB0aGVtZSA9PT0gJ2RhcmsnIHx8ICghdGhlbWUgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzKTtcclxuICAvLyAgIHNldElzRGFya01vZGUocHJlZmVyc0RhcmspO1xyXG4gIC8vICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ2RhcmsnLCBwcmVmZXJzRGFyayk7XHJcbiAgLy8gfSwgW10pO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIkhISEVIRUhFOlwiLCBwcm9ibGVtcyk7XHJcbiAgICBpZiAoIXByb2JsZW1zIHx8IHByb2JsZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgaWYgKG1hdGNoTG9ja2VkKSByZXR1cm47IC8vIGFscmVhZHkgbG9ja2VkXHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIkhISEVIRUhFOlwiKVxyXG4gICAgY29uc3QgdyA9IGZpbmRXaW5uZXJGcm9tU29sdmVkKHNvbHZlZCwgcHJvYmxlbXMsIGdyaWRTaXplKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiUDogXCIsIHcpO1xyXG4gICAgaWYgKHcgJiYgIXdpbm5lcikge1xyXG4gICAgICAgIHNldFdpbm5lcih3KTtcclxuICAgICAgICBzZXRDb25mZXR0aUFjdGl2ZSh0cnVlKTtcclxuICAgICAgICBzZXRNYXRjaExvY2tlZCh0cnVlKTtcclxuICAgICAgICBjb25zdCB0ZWFtT2JqID0gbWF0Y2g/LnRlYW1zPy5maW5kKFxyXG4gICAgICAgICAgICB0ID0+IHQuY29sb3I/LnRvTG93ZXJDYXNlKCkgPT09IGN1cnJlbnRUZWFtPy50b0xvd2VyQ2FzZSgpIHx8IHQubmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gY3VycmVudFRlYW0/LnRvTG93ZXJDYXNlKClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBkaXNwbGF5IG5hbWUgKGZvciBVSSkgYW5kIGtleSAoZm9yIGludGVybmFsIHVzZSlcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZGlzcGxheU5hbWU6ICcsIHRlYW1PYmo/Lm5hbWUpXHJcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSB0ZWFtT2JqPy5uYW1lID8/IGN1cnJlbnRUZWFtO1xyXG4gICAgICAgIGNvbnN0IHRlYW1LZXkgPSB0ZWFtT2JqPy5jb2xvcj8udG9Mb3dlckNhc2UoKSA/PyBjdXJyZW50VGVhbT8udG9Mb3dlckNhc2U/LigpID8/ICd1bmtub3duJztcclxuXHJcbiAgICAgICAgLy8gYWRkIGZpbmFsIHN1bW1hcnkgbGluZSB0byB0aGUgbG9nXHJcbiAgICAgICAgLy8gY29uc3Qga2V5ID0gYCR7cHJvYmxlbXNbaV0uY29udGVzdElkfS0ke3Byb2JsZW1zW2ldLmluZGV4fWA7XHJcbiAgICAgICAgc2V0TG9nKHByZXYgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb2JsZW1MaXN0ID0gdy5rZXlzLm1hcChrID0+IGsucmVwbGFjZSgnLScsICcnKSkuam9pbignLCAnKTsgLy8gYmFzaWMgZm9ybWF0dGluZ1xyXG4gICAgICAgIGNvbnN0IGZpbmFsTXNnID0gYCR7ZGlzcGxheU5hbWV9IGNvbXBsZXRlZCAke3cudHlwZSA9PT0gJ3JvdycgPyAnYSByb3cnIDogdy50eXBlID09PSAnY29sJyA/ICdhIGNvbHVtbicgOiB3LnR5cGUgPT09ICdkaWFnJyA/ICd0aGUgbWFpbiBkaWFnb25hbCcgOiAndGhlIGFudGktZGlhZ29uYWwnfWA7XHJcbiAgICAgICAgcmV0dXJuIFt7IG1lc3NhZ2U6IGZpbmFsTXNnLCB0ZWFtOiB3LnRlYW0udG9Mb3dlckNhc2UoKSwga2V5OiBcIlwiIH0sIC4uLnByZXZdLnNsaWNlKDAsIDEwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gT1BUSU9OQUw6IHBlcnNpc3QgYSBsb2NrIG9uIHRoZSBzZXJ2ZXIgKGlmIHlvdSBhZGQgYSAvYXBpL2xvY2tNYXRjaCBlbmRwb2ludClcclxuICAgICAgICAvLyBmZXRjaCgnL2FwaS9sb2NrTWF0Y2gnLCB7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtYXRjaElkOiBtYXRjaD8uaWQgfSkgfSkuY2F0Y2goY29uc29sZS53YXJuKTtcclxuICAgIH1cclxuICAgIH0sIFtzb2x2ZWQscHJvYmxlbXMgLCB3aW5uZXJdKTtcclxuXHJcblxyXG4gIC8vIGZ1bmN0aW9uIHRvZ2dsZVRoZW1lKCkge1xyXG4gIC8vICAgY29uc3QgbmV3VGhlbWUgPSAhaXNEYXJrTW9kZTtcclxuICAvLyAgIHNldElzRGFya01vZGUobmV3VGhlbWUpO1xyXG4gIC8vICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RoZW1lJywgbmV3VGhlbWUgPyAnZGFyaycgOiAnbGlnaHQnKTtcclxuICAvLyAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdkYXJrJywgbmV3VGhlbWUpO1xyXG4gIC8vIH1cclxuXHJcbiAgZnVuY3Rpb24gZmluZFdpbm5lckZyb21Tb2x2ZWQoc29sdmVkTWFwOiBSZWNvcmQ8c3RyaW5nLCBTb2x2ZWRJbmZvPiwgcHJvYmxlbXNBcnI6IFByb2JsZW1bXSwgZ1NpemU6IG51bWJlcik6IFdpbm5lciB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIlBQUDogXCIsIHByb2JsZW1zQXJyKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiOlA6IFwiLCBzb2x2ZWRNYXApO1xyXG4gICAgaWYgKCFwcm9ibGVtc0FyciB8fCBwcm9ibGVtc0Fyci5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgY29uc3Qgc2l6ZSA9IGdTaXplO1xyXG4gICAgICAvLyBEZWZlbnNpdmU6IGVuc3VyZSBwcm9ibGVtc0FyciBsZW5ndGggbWF0Y2hlcyBleHBlY3RlZCBncmlkIHNpemUgKHNpemUgKiBzaXplKS5cclxuICAgIC8vIElmIGl0IGRvZXNuJ3QsIGJhaWwgb3V0IGFuZCBhdm9pZCBpbmRleCBPT0IuIExvZyBmb3IgZGVidWdnaW5nLlxyXG4gICAgaWYgKHByb2JsZW1zQXJyLmxlbmd0aCAhPT0gc2l6ZSAqIHNpemUpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBmaW5kV2lubmVyRnJvbVNvbHZlZDogbWlzbWF0Y2ggcHJvYmxlbXMubGVuZ3RoICgke3Byb2JsZW1zQXJyLmxlbmd0aH0pIHZzIGV4cGVjdGVkICgke3NpemUgKiBzaXplfSkuIFNraXBwaW5nIHdpbm5lciBkZXRlY3Rpb24uYCk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gb3duZXIgZ3JpZDogdGVhbSBuYW1lIHN0cmluZyB8IG51bGxcclxuICAgIGNvbnN0IG93bmVyR3JpZDogKHN0cmluZyB8IG51bGwpW11bXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKCkgPT4gQXJyYXkoc2l6ZSkuZmlsbChudWxsKSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2JsZW1zQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgciA9IE1hdGguZmxvb3IoaSAvIHNpemUpO1xyXG4gICAgICAgIGNvbnN0IGMgPSBpICUgc2l6ZTtcclxuICAgICAgICBvd25lckdyaWRbcl1bY10gPSBzb2x2ZWRNYXBbaV0/LnRlYW0gPz8gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByb3dzXHJcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHNpemU7IHIrKykge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gb3duZXJHcmlkW3JdWzBdO1xyXG4gICAgICAgIGlmIChmaXJzdCAmJiBvd25lckdyaWRbcl0uZXZlcnkoY2VsbCA9PiBjZWxsID09PSBmaXJzdCkpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbSh7bGVuZ3RoOiBzaXplfSwgKF8sIGMpID0+IGAke3Byb2JsZW1zQXJyW3Iqc2l6ZSArIGNdLmNvbnRlc3RJZH0tJHtwcm9ibGVtc0FycltyKnNpemUgKyBjXS5pbmRleH1gKTtcclxuICAgICAgICByZXR1cm4geyB0ZWFtOiBmaXJzdCwgdHlwZTogJ3JvdycsIGluZGV4OiByLCBrZXlzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbHVtbnNcclxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgc2l6ZTsgYysrKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSBvd25lckdyaWRbMF1bY107XHJcbiAgICAgICAgaWYgKGZpcnN0ICYmIG93bmVyR3JpZC5ldmVyeShyb3cgPT4gcm93W2NdID09PSBmaXJzdCkpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbSh7bGVuZ3RoOiBzaXplfSwgKF8sIHIpID0+IGAke3Byb2JsZW1zQXJyW3Iqc2l6ZSArIGNdLmNvbnRlc3RJZH0tJHtwcm9ibGVtc0FycltyKnNpemUgKyBjXS5pbmRleH1gKTtcclxuICAgICAgICByZXR1cm4geyB0ZWFtOiBmaXJzdCwgdHlwZTogJ2NvbCcsIGluZGV4OiBjLCBrZXlzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG1haW4gZGlhZ29uYWxcclxuICAgIGNvbnN0IGZpcnN0RGlhZyA9IG93bmVyR3JpZFswXVswXTtcclxuICAgIGlmIChmaXJzdERpYWcgJiYgb3duZXJHcmlkLmV2ZXJ5KChyb3csIGkpID0+IHJvd1tpXSA9PT0gZmlyc3REaWFnKSkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHtsZW5ndGg6IHNpemV9LCAoXywgaSkgPT4gYCR7cHJvYmxlbXNBcnJbaSpzaXplICsgaV0uY29udGVzdElkfS0ke3Byb2JsZW1zQXJyW2kqc2l6ZSArIGldLmluZGV4fWApO1xyXG4gICAgICAgIHJldHVybiB7IHRlYW06IGZpcnN0RGlhZywgdHlwZTogJ2RpYWcnLCBpbmRleDogMCwga2V5cyB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFudGktZGlhZ29uYWxcclxuICAgIGNvbnN0IGZpcnN0QW50aSA9IG93bmVyR3JpZFswXVtzaXplIC0gMV07XHJcbiAgICBpZiAoZmlyc3RBbnRpICYmIG93bmVyR3JpZC5ldmVyeSgocm93LCBpKSA9PiByb3dbc2l6ZSAtIDEgLSBpXSA9PT0gZmlyc3RBbnRpKSkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHtsZW5ndGg6IHNpemV9LCAoXywgaSkgPT4gYCR7cHJvYmxlbXNBcnJbaSpzaXplICsgKHNpemUgLSAxIC0gaSldLmNvbnRlc3RJZH0tJHtwcm9ibGVtc0FycltpKnNpemUgKyAoc2l6ZSAtIDEgLSBpKV0uaW5kZXh9YCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdGVhbTogZmlyc3RBbnRpLCB0eXBlOiAnYW50aS1kaWFnJywgaW5kZXg6IDEsIGtleXMgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZVNxdWFyZShpOiBudW1iZXIpIHtcclxuICAgIGlmIChtYXRjaExvY2tlZCkgcmV0dXJuO1xyXG4gICAgY29uc3Qga2V5ID0gYCR7cHJvYmxlbXNbaV0uY29udGVzdElkfS0ke3Byb2JsZW1zW2ldLmluZGV4fWA7XHJcbiAgICBpZiAoc29sdmVkW2tleV0pIHJldHVybjtcclxuXHJcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcclxuICAgIHNldFNvbHZlZChwcmV2ID0+ICh7IC4uLnByZXYsIFtrZXldOiB7IHRlYW06IGN1cnJlbnRUZWFtLCB0aW1lc3RhbXA6IHRpbWUgfSB9KSk7XHJcbiAgICBjb25zdCBwcm9iID0gcHJvYmxlbXNbaV07XHJcbiAgICBjb25zdCBwcm9ibGVtSWQgPSBgJHtwcm9iLmNvbnRlc3RJZH0ke3Byb2IuaW5kZXh9YDtcclxuICAgIGNvbnN0IHRlYW1PYmogPSBtYXRjaD8udGVhbXM/LmZpbmQoXHJcbiAgICAgICAgdCA9PiB0LmNvbG9yPy50b0xvd2VyQ2FzZSgpID09PSBjdXJyZW50VGVhbT8udG9Mb3dlckNhc2UoKSB8fCB0Lm5hbWU/LnRvTG93ZXJDYXNlKCkgPT09IGN1cnJlbnRUZWFtPy50b0xvd2VyQ2FzZSgpXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBjb25zb2xlLmxvZygndGhlIHRlYW1zOiAnLCBtYXRjaD8udGVhbXMpO1xyXG4gICAgLy8gZGlzcGxheSBuYW1lIChmb3IgVUkpIGFuZCBrZXkgKGZvciBpbnRlcm5hbCB1c2UpXHJcbiAgICAvLyBjb25zb2xlLmxvZygnZGlzcGxheU5hbWU6ICcsIHRlYW1PYmo/Lm5hbWUpXHJcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IHRlYW1PYmo/Lm5hbWUgPz8gY3VycmVudFRlYW07XHJcbiAgICBjb25zdCB0ZWFtS2V5ID0gdGVhbU9iaj8uY29sb3I/LnRvTG93ZXJDYXNlKCkgPz8gY3VycmVudFRlYW0/LnRvTG93ZXJDYXNlPy4oKSA/PyAndW5rbm93bic7XHJcbiAgICAvLyBjb25zb2xlLmxvZygnTmFtZTogJywgZGlzcGxheU5hbWUpO1xyXG4gICAgY29uc3QgbmV3RW50cnkgPSB7XHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIG1lc3NhZ2U6IGAke2Rpc3BsYXlOYW1lfSBzb2x2ZWQgJHtwcm9iLm5hbWV9ICgke3Byb2JsZW1JZH0pYCxcclxuICAgICAgICB0ZWFtOiB0ZWFtS2V5LFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXRMb2cocHJldiA9PiB7XHJcbiAgICAvLyAgIGNvbnN0IG5ld0VudHJ5ID0ge1xyXG4gICAgLy8gICAgIG1lc3NhZ2U6IGAke3RpbWV9IOKAlCAke2N1cnJlbnRUZWFtfSBzb2x2ZWQgJHtwcm9ibGVtc1tpXS5uYW1lfWAsXHJcbiAgICAvLyAgICAgdGVhbTogY3VycmVudFRlYW0udG9Mb3dlckNhc2UoKSwgLy8gbWFrZSBzdXJlIHRlYW0gbWF0Y2hlcyBrZXlzIGluIHRlYW1Db2xvcnNcclxuICAgIC8vICAgfTtcclxuICAgICAgY29uc3QgY29tYmluZWQgPSBbbmV3RW50cnksIC4uLnByZXZdO1xyXG5cclxuICAgICAgLy8gT3B0aW9uYWw6IHJlbW92ZSBkdXBsaWNhdGUgbWVzc2FnZXMgaWYgbmVlZGVkXHJcbiAgICAgIGNvbnN0IHVuaXF1ZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCB0eXBlb2YgbmV3RW50cnk+KCk7XHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY29tYmluZWQpIHtcclxuICAgICAgICBpZiAoIXVuaXF1ZU1hcC5oYXMoZW50cnkua2V5KSkge1xyXG4gICAgICAgICAgdW5pcXVlTWFwLnNldChlbnRyeS5rZXksIGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlTWFwLnZhbHVlcygpKS5zbGljZSgwLCAxMCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG5cclxuICAvLyA9PT09PT09IEVBUkxZIFJFVFVSTiBpZiBubyBtYXRjaCA9PT09PT09PT09PVxyXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPExvYWRpbmcgLz47ICAgICAgLy8gd2hpbGUgZmV0Y2hpbmdcclxuICBpZighbWF0Y2gpIHtcclxuICAgIHJldHVybiA8bWFpbiBjbGFzc05hbWU9XCJwLTZcIj5NYXRjaCBub3QgZm91bmQ8L21haW4+O1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PSBNQVRDSCBJUyBOT1QgTlVMTCBCRUxPVywgU0FGRSBUTyBVU0UgbWF0Y2ggU1RBUlQgPT09PVxyXG5cclxuICBjb25zdCBtYXRjaFN0YXJ0ID0gbmV3IERhdGUobWF0Y2guc3RhcnRUaW1lKTtcclxuICBjb25zdCBtYXRjaEVuZCA9IG5ldyBEYXRlKG1hdGNoU3RhcnQuZ2V0VGltZSgpICsgbWF0Y2guZHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTtcclxuICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gIGNvbnN0IG1hdGNoSGFzU3RhcnRlZCA9IGN1cnJlbnRUaW1lID49IG1hdGNoU3RhcnQ7XHJcbiAgY29uc3QgbWF0Y2hIYXNFbmRlZCA9IGN1cnJlbnRUaW1lID49IG1hdGNoRW5kO1xyXG4gIGNvbnN0IG1hdGNoT25nb2luZyA9IG1hdGNoSGFzU3RhcnRlZCAmJiAhbWF0Y2hIYXNFbmRlZCAmJiAhbWF0Y2hMb2NrZWQ7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8bWFpbiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctd2hpdGUgZGFyazpiZy1ncmF5LTkwMCBkYXJrOnRleHQtZ3JheS0xMDAgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMzAwXCI+XHJcblxyXG4gICAgICAgICAgICB7LyogQ29uZmV0dGkgb24gd2lubmVyICovfVxyXG4gICAgICAgICAgICB7d2lubmVyICYmIGNvbmZldHRpQWN0aXZlICYmIDxDb25mZXR0aSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSByZWN5Y2xlPXtmYWxzZX0gbnVtYmVyT2ZQaWVjZXM9ezMwMH0gLz59XHJcblxyXG5cclxuICAgICAgey8qIEhlYWRlciAqL31cclxuICAgICAgPGhlYWRlciBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctZ3JheS0xMDAgZGFyazpiZy1ncmF5LTgwMCBib3JkZXItYiBkYXJrOmJvcmRlci1ncmF5LTcwMCBzaGFkb3ctc20gc3RpY2t5IHRvcC0wIHotMjBcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTZ4bCBteC1hdXRvIGZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBweC00IHB5LTNcIj5cclxuICAgICAgICAgIDxhIGhyZWY9XCJodHRwOi8vbG9jYWxob3N0OjMwMDAvaG9tZVwiPlxyXG4gICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1leHRyYWJvbGQgYmctZ3JhZGllbnQtdG8tciBmcm9tLXB1cnBsZS01MDAgdG8tcGluay01MDAgdGV4dC10cmFuc3BhcmVudCBiZy1jbGlwLXRleHQgdHJhY2tpbmctd2lkZVwiPlxyXG4gICAgICAgICAgICAgIEJpbmdvIENQXHJcbiAgICAgICAgICAgIDwvaDE+XHJcbiAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNCBib3JkZXItbCBwbC02IG1sLTQgZGFyazpib3JkZXItZ3JheS02MDBcIj5cclxuICAgICAgICAgICAge1snSG9tZScsICdJQ1BDIE1vZGUnLCAnSU9JIE1vZGUnLCAnSGVscCddLm1hcChsYWJlbCA9PiAoXHJcbiAgICAgICAgICAgICAgPGEgaHJlZj17YCR7bGlua3NbbGFiZWxdfWB9PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e2xhYmVsfSBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlciBweC00IHB5LTEgcm91bmRlZCBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIGhvdmVyOmJnLWdyYXktMzAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgdGV4dC1zbVwiPlxyXG4gICAgICAgICAgICAgICAgICB7bGFiZWx9XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICB7LyogPGJ1dHRvbiBvbkNsaWNrPXt0b2dnbGVUaGVtZX0gY2xhc3NOYW1lPVwiY3Vyc29yLXBvaW50ZXIgcC0yIHJvdW5kZWQtZnVsbCBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIGhvdmVyOmJnLWdyYXktMzAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgdHJhbnNpdGlvblwiPlxyXG4gICAgICAgICAgICAgIHtpc0RhcmtNb2RlID8gKFxyXG4gICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJoLTUgdy01IHRleHQteWVsbG93LTMwMFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlV2lkdGg9ezJ9IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMSAxMi43OUE5IDkgMCAxIDEgMTEuMjEgM0E3IDcgMCAwIDAgMjEgMTIuNzl6XCIgLz5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImgtNSB3LTUgdGV4dC15ZWxsb3ctNjAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2VXaWR0aD17Mn0gdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjVcIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEyIDF2Mk0xMiAyMXYyTTQuMjIgNC4yMmwxLjQyIDEuNDJNMTguMzYgMTguMzZsMS40MiAxLjQyTTEgMTJoMk0yMSAxMmgyTTQuMjIgMTkuNzhsMS40Mi0xLjQyTTE4LjM2IDUuNjRsMS40Mi0xLjQyXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPiAqL31cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2hlYWRlcj5cclxuXHJcbiAgICAgIHsvKiBTaG93IHRpbWUgaW5mbyAqL31cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBtdC00XCI+XHJcbiAgICAgICAgeyFtYXRjaEhhc1N0YXJ0ZWQgJiYgKFxyXG4gICAgICAgICAgPENvdW50ZG93blRvU3RhcnQgc3RhcnRUaW1lPXttYXRjaFN0YXJ0fSAvPlxyXG4gICAgICAgICl9XHJcbiAgICAgICAge21hdGNoSGFzRW5kZWQgJiYgKFxyXG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtNTAwXCI+TWF0Y2ggaGFzIGVuZGVkLjwvcD5cclxuICAgICAgICApfVxyXG4gICAgICAgIHttYXRjaE9uZ29pbmcgJiYgbWF0Y2ggJiYgKFxyXG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JlZW4tNTAwXCI+XHJcbiAgICAgICAgICBNYXRjaCBlbmRzIGluIHtmb3JtYXREdXJhdGlvbihtYXRjaEVuZC5nZXRUaW1lKCkgLSBEYXRlLm5vdygpKX1cclxuICAgICAgICA8L3A+XHJcbiAgICAgICAgICApfVxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIHsvKiBTaG93IHByb2JsZW0gZ3JpZCBhbHdheXMgZHVyaW5nIG9yIGFmdGVyIG1hdGNoICovfVxyXG4gICAgICB7bWF0Y2hIYXNTdGFydGVkID8gKCBcclxuICAgICAgbG9hZGluZyA/IChcclxuICAgICAgICA8TG9hZGluZyAvPlxyXG4gICAgICApIDogKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgZ3JpZCAke2dyaWRDbGFzc2VzW2dyaWRTaXplXX0gZ2FwLXgtMCBnYXAteS00IGp1c3RpZnktaXRlbXMtY2VudGVyIG10LTQgbXgtNzBgfT5cclxuICAgICAgICAgIHtwcm9ibGVtcy5tYXAoKHByb2JsZW0sIGlkeCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtwcm9ibGVtLmNvbnRlc3RJZH0tJHtwcm9ibGVtLmluZGV4fWA7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvbHZlZEluZm8gPSBzb2x2ZWRba2V5XTtcclxuICAgICAgICAgICAgY29uc3Qgb3duZXJUZWFtID0gc29sdmVkSW5mbz8udGVhbSA/PyBwb3NpdGlvbk93bmVyc1twcm9ibGVtLnBvc2l0aW9uID8/IGlkeF07IC8vIGZhbGxiYWNrIGJ5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGlzV2lubmluZ0NlbGwgPSB3aW5uZXI/LmtleXM/LmluY2x1ZGVzKGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZW5kZXJpbmcgcHJvYmxlbScsIGtleSwgJ3NvbHZlZCBieScsIHNvbHZlZEluZm8/LnRlYW0sICd0ZWFtQ29sb3I6JywgdGVhbUNvbG9yc1tzb2x2ZWRJbmZvPy50ZWFtXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlYW1Db2xvciA9IG93bmVyVGVhbVxyXG4gICAgICAgICAgICAgID8gKHRlYW1Db2xvcnNbb3duZXJUZWFtXSB8fCAnYmctZ3JheS01MDAgdGV4dC13aGl0ZScpXHJcbiAgICAgICAgICAgICAgOiAnYmctd2hpdGUgaG92ZXI6YmctYmx1ZS0xMDAgZGFyazpiZy1ncmF5LTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtOTAwIHRleHQtZ3JheS04MDAgZGFyazp0ZXh0LWdyYXktMjAwJztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAga2V5PXtgJHtwcm9ibGVtLmNvbnRlc3RJZH0tJHtwcm9ibGVtLmluZGV4fWB9XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PlxyXG4gICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihcclxuICAgICAgICAgICAgICAgICAgICBgaHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LyR7cHJvYmxlbS5jb250ZXN0SWR9L3Byb2JsZW0vJHtwcm9ibGVtLmluZGV4fWAsXHJcbiAgICAgICAgICAgICAgICAgICAgJ19ibGFuaydcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Eb3VibGVDbGljaz17KCkgPT4geyAvLyBET05UIGZvcmdldCB0byByZW1vdmUgaXQgbGF0ZXJcclxuICAgICAgICAgICAgICAgIC8vIC8vIGRvdWJsZSBjbGljayB3aWxsIGxvY2FsbHkgbWFyayBmb3IgdGVzdGluZyAodG9nZ2xlU3F1YXJlKSBidXQgZGlzYWJsZWQgYWZ0ZXIgbG9ja1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFtYXRjaExvY2tlZCkgdG9nZ2xlU3F1YXJlKGlkeCk7XHJcbiAgICAgICAgICAgICAgICAvLyB9fVxyXG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmFkZCgnc2NhbGUtWzEuMDRdJywgJ3NoYWRvdy1tZCcpO1xyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NjYWxlLVsxLjA0XScsICdzaGFkb3ctbWQnKTtcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B3LTM2IGgtMjQgcC0yIGZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtY2VudGVyIHJvdW5kZWQgc2hhZG93IGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwXHJcbiAgICAgICAgICAgICAgICAgICR7dGVhbUNvbG9yfSAke293bmVyVGVhbSA/ICd0ZXh0LXdoaXRlJyA6ICcnfSAke2lzV2lubmluZ0NlbGwgPyAnIHJpbmctNCByaW5nLXllbGxvdy00MDAgc2NhbGUtWzEuMDZdJyA6ICcnfWB9XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtc2VtaWJvbGRcIj5cclxuICAgICAgICAgICAgICAgICAge3Byb2JsZW0ucmF0aW5nfSAtIHtwcm9ibGVtLmluZGV4fVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgbXQtMVwiPntwcm9ibGVtLm5hbWV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICB7Lyoge3NvbHZlZEluZm8gJiYgKFxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgbXQtMSBpdGFsaWNcIj5cclxuICAgICAgICAgICAgICAgICAgICBDbGFpbWVkIGJ5IHtzb2x2ZWRJbmZvLnRlYW19IGF0IHtzb2x2ZWRJbmZvLnRpbWVzdGFtcH1cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApfSAqL31cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgICAgKTogbnVsbH1cclxuXHJcbiAgICAgIHsvKiBMb2cgUGFuZWwgKi99XHJcbiAgICAgIHtzaG93TG9nICYmIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIGJvdHRvbS00IGxlZnQtMSB3LTcyIG1heC1oLVs4MHZoXSBvdmVyZmxvdy15LWF1dG8gYm9yZGVyIHJvdW5kZWQgcC0zIGJnLXdoaXRlIGRhcms6YmctZ3JheS05MDAgc2hhZG93IHotMzBcIj5cclxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItMlwiPlNvbHZlIExvZzwvaDI+XHJcbiAgICAgICAgICB7bG9nLmxlbmd0aCA9PT0gMCA/IChcclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNTAwXCI+Tm8gc29sdmVzIHlldDwvcD5cclxuICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHNwYWNlLXktMlwiPlxyXG4gICAgICAgICAgICAgIHtsb2cubWFwKChlbnRyeSwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiZ0NvbG9yID0gdGVhbUNvbG9yc1tlbnRyeS50ZWFtXSB8fCAnYmctZ3JheS0yMDAgZGFyazpiZy1ncmF5LTcwMCc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICA8bGlcclxuICAgICAgICAgICAgICAgICAgICBrZXk9e2lkeH1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2JnQ29sb3J9IHRleHQtd2hpdGUgcHgtMyBweS0yIHJvdW5kZWQgc2hhZG93LXNtYH1cclxuICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIHtlbnRyeS5tZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcblxyXG4gICAgICB7LyogVG9nZ2xlIEJ1dHRvbiAoYWJvdmUgbG9nKSAqL31cclxuICAgICAgPGJ1dHRvblxyXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3dMb2cocHJldiA9PiAhcHJldil9XHJcbiAgICAgICAgY2xhc3NOYW1lPVwiY3Vyc29yLXBvaW50ZXIgZml4ZWQgYm90dG9tLVtjYWxjKDRyZW0rNzZ2aCldIGxlZnQtNCBweC0zIHB5LTEgYmctZ3JheS0zMDAgZGFyazpiZy1ncmF5LTcwMCB0ZXh0LWJsYWNrIGRhcms6dGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgdHJhbnNpdGlvbiB6LTQwXCJcclxuICAgICAgPlxyXG4gICAgICAgIHtzaG93TG9nID8gJ0hpZGUgTG9nJyA6ICdTaG93IExvZyd9XHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgPC9tYWluPlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUGFyYW1zIiwiTG9hZGluZyIsIkNvbmZldHRpIiwidXNlUmVmIiwidGVhbUNvbG9ycyIsInJlZCIsImJsdWUiLCJncmVlbiIsInB1cnBsZSIsIm9yYW5nZSIsInBpbmsiLCJ5ZWxsb3ciLCJ0ZWFsIiwibGlua3MiLCJncmlkQ2xhc3NlcyIsInVzZVdpbmRvd1NpemUiLCJpc0NsaWVudCIsInNpemUiLCJzZXRTaXplIiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJvblJlc2l6ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibm90aWZ5QnJvd3NlciIsInRpdGxlIiwiYm9keSIsIk5vdGlmaWNhdGlvbiIsInBlcm1pc3Npb24iLCJlIiwicmVxdWVzdFBlcm1pc3Npb24iLCJ0aGVuIiwibm9ybWFsaXplUHJvYmxlbXNGcm9tU2VydmVyIiwicmF3IiwiQXJyYXkiLCJpc0FycmF5IiwiYWN0aXZlIiwiZmlsdGVyIiwicCIsImhhc1Bvc2l0aW9uIiwiZXZlcnkiLCJwb3NpdGlvbiIsImJ5UG9zIiwiTWFwIiwicG9zIiwiaGFzIiwic2V0IiwiZnJvbSIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJfIiwic2VlbiIsIlNldCIsInJlc3VsdCIsImtleSIsImNvbnRlc3RJZCIsImluZGV4IiwiYWRkIiwicHVzaCIsIkhvbWUiLCJwYXJhbXMiLCJyYXdJZCIsImlkIiwic2hvd0xvZyIsInNldFNob3dMb2ciLCJjdXJyZW50VGVhbSIsInNldEN1cnJlbnRUZWFtIiwicHJvYmxlbXMiLCJzZXRQcm9ibGVtcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZ3JpZFNpemUiLCJzZXRncmlkU2l6ZSIsInNvbHZlZCIsInNldFNvbHZlZCIsImxvZyIsInNldExvZyIsIm1hdGNoIiwic2V0TWF0Y2giLCJub3ciLCJzZXROb3ciLCJEYXRlIiwid2lubmVyIiwic2V0V2lubmVyIiwibWF0Y2hMb2NrZWQiLCJzZXRNYXRjaExvY2tlZCIsImNvbmZldHRpQWN0aXZlIiwic2V0Q29uZmV0dGlBY3RpdmUiLCJwb3NpdGlvbk93bmVycyIsInNldFBvc2l0aW9uT3duZXJzIiwibm90aWZpZWRSZWYiLCJwZXJzaXN0Tm90aWZpZWQiLCJtYXRjaElkIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjdXJyZW50IiwiZ2V0SXRlbSIsImFyciIsInBhcnNlIiwiZmV0Y2hNYXRjaCIsInJlcyIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwib2siLCJjb25zb2xlIiwiZXJyb3IiLCJ0ZXh0IiwiZGF0YSIsImpzb24iLCJtYXRjaE9iaiIsInNvbHZlZE1hcCIsIm5ld0xvZ0VudHJpZXMiLCJwb3NPd25lcnMiLCJ0ZWFtc0Zyb21TZXJ2ZXIiLCJ0ZWFtcyIsInNvbHZlTG9nIiwiZm9yRWFjaCIsImVudHJ5IiwiZGlzcGxheU5hbWUiLCJ0ZWFtS2V5IiwicmVzb2x2ZVRlYW1EaXNwbGF5QW5kS2V5IiwidGVhbSIsInByb2JsZW0iLCJwcm9ibGVtTmFtZSIsIm5hbWUiLCJjb250ZXN0QW5kSW5kZXgiLCJtZXNzYWdlIiwicHJldiIsImNvbWJpbmVkIiwidW5pcXVlTWFwIiwidmFsdWVzIiwic2xpY2UiLCJ3YXJuIiwiZXJyIiwidGVhbUlkZW50aWZpZXIiLCJ0ZWFtc0xpc3RQYXJhbSIsInRlYW1zTGlzdCIsInNlYXJjaCIsInRvTG93ZXJDYXNlIiwidGVhbU9iaiIsImZpbmQiLCJ0IiwiY29sb3IiLCJsZW5ndGgiLCJtYXRjaFN0YXJ0Iiwic3RhcnRUaW1lIiwibWF0Y2hFbmQiLCJnZXRUaW1lIiwiZHVyYXRpb25NaW51dGVzIiwiZmV0Y2hQb2xsIiwicG9sbFJlcyIsIm1ldGhvZCIsImhlYWRlcnMiLCJwb2xsRGF0YSIsInVwZGF0ZWQiLCJwcm9ibGVtVXBkYXRlcyIsInVuZGVmaW5lZCIsInJhdGluZyIsIm5vcm1hbGl6ZWQiLCJPYmplY3QiLCJrZXlzIiwiayIsInVwZCIsInByZXZMb2ciLCJkZWR1cGVkIiwicHJldk1lc3NhZ2VzIiwieCIsIm5lIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzdGFydCIsImVuZCIsImxlbiIsImZvcm1hdER1cmF0aW9uIiwibXMiLCJ0b3RhbFNlY29uZHMiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJob3VycyIsIlN0cmluZyIsInBhZFN0YXJ0IiwibWludXRlcyIsInNlY29uZHMiLCJmb3JtYXRDb3VudGRvd24iLCJ0b1N0cmluZyIsIkNvdW50ZG93blRvU3RhcnQiLCJ0aW1lTGVmdCIsInNldFRpbWVMZWZ0IiwiY2xhc3NOYW1lIiwidyIsImZpbmRXaW5uZXJGcm9tU29sdmVkIiwicHJvYmxlbUxpc3QiLCJyZXBsYWNlIiwiam9pbiIsImZpbmFsTXNnIiwidHlwZSIsInByb2JsZW1zQXJyIiwiZ1NpemUiLCJvd25lckdyaWQiLCJmaWxsIiwiaSIsInIiLCJjIiwiZmlyc3QiLCJjZWxsIiwicm93IiwiZmlyc3REaWFnIiwiZmlyc3RBbnRpIiwidG9nZ2xlU3F1YXJlIiwidGltZSIsInRvTG9jYWxlVGltZVN0cmluZyIsInRpbWVzdGFtcCIsInByb2IiLCJwcm9ibGVtSWQiLCJuZXdFbnRyeSIsIm1haW4iLCJjdXJyZW50VGltZSIsIm1hdGNoSGFzU3RhcnRlZCIsIm1hdGNoSGFzRW5kZWQiLCJtYXRjaE9uZ29pbmciLCJyZWN5Y2xlIiwibnVtYmVyT2ZQaWVjZXMiLCJoZWFkZXIiLCJkaXYiLCJocmVmIiwiaDEiLCJsYWJlbCIsImJ1dHRvbiIsImlkeCIsInNvbHZlZEluZm8iLCJvd25lclRlYW0iLCJpc1dpbm5pbmdDZWxsIiwiaW5jbHVkZXMiLCJ0ZWFtQ29sb3IiLCJvbkNsaWNrIiwib3BlbiIsIm9uTW91c2VFbnRlciIsImN1cnJlbnRUYXJnZXQiLCJjbGFzc0xpc3QiLCJvbk1vdXNlTGVhdmUiLCJyZW1vdmUiLCJoMiIsInVsIiwiYmdDb2xvciIsImxpIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/match/[id]/page.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Cbingo-cp%5C%5Csrc%5C%5Capp%5C%5Cmatch%5C%5C%5Bid%5D%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);