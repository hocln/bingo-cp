"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/poll-submissions";
exports.ids = ["pages/api/poll-submissions"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fpoll-submissions&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cpoll-submissions.ts&middlewareConfigBase64=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fpoll-submissions&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cpoll-submissions.ts&middlewareConfigBase64=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   handler: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/api-utils */ \"(api-node)/./node_modules/next/dist/server/api-utils/index.js\");\n/* harmony import */ var next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_poll_submissions_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages\\api\\poll-submissions.ts */ \"(api-node)/./pages/api/poll-submissions.ts\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(api-node)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(api-node)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n// Import the userland code.\n\n\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_poll_submissions_ts__WEBPACK_IMPORTED_MODULE_4__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_3__.hoist)(_pages_api_poll_submissions_ts__WEBPACK_IMPORTED_MODULE_4__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_2__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/poll-submissions\",\n        pathname: \"/api/poll-submissions\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_poll_submissions_ts__WEBPACK_IMPORTED_MODULE_4__,\n    distDir: \".next\" || 0,\n    projectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    let srcPage = \"/api/poll-submissions\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {}\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.getTracer)();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: undefined,\n                multiZoneDraftMode: Boolean(\"false\"),\n                trustHostHeader: undefined,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/poll-submissions\",\n                projectDir:  false || '',\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_6__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_5__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        (0,next_dist_server_api_utils__WEBPACK_IMPORTED_MODULE_0__.sendError)(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGcG9sbC1zdWJtaXNzaW9ucyZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDcG9sbC1zdWJtaXNzaW9ucy50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUN1QztBQUNyQztBQUMxRDtBQUM4RDtBQUNVO0FBQ0Y7QUFDdEU7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLDJEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQywyREFBUTtBQUNwQztBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELGdCQUFnQixNQUF1QztBQUN2RCxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUIsRUFBRSxFQUUxQjtBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBLHVCQUF1Qiw0RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2Q0FBNkMsU0FBNkM7QUFDMUYsNENBQTRDLE9BQXdDO0FBQ3BGLGlDQUFpQyxTQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBdUM7QUFDbkU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnRkFBYztBQUMvRSwrREFBK0QseUNBQXlDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsRUFBRSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0JBQWtCO0FBQ2xCLHVDQUF1QyxRQUFRLEVBQUUsUUFBUTtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUFTO0FBQ2pCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZW5kRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9hcGktdXRpbHNcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXHBvbGwtc3VibWlzc2lvbnMudHNcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgJ2RlZmF1bHQnKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsICdjb25maWcnKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcG9sbC1zdWJtaXNzaW9uc1wiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3BvbGwtc3VibWlzc2lvbnNcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiAnJyxcbiAgICAgICAgZmlsZW5hbWU6ICcnXG4gICAgfSxcbiAgICB1c2VybGFuZCxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnXG59KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICBsZXQgc3JjUGFnZSA9IFwiL2FwaS9wb2xsLXN1Ym1pc3Npb25zXCI7XG4gICAgLy8gdHVyYm9wYWNrIGRvZXNuJ3Qgbm9ybWFsaXplIGAvaW5kZXhgIGluIHRoZSBwYWdlIG5hbWVcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHRvIHByb2Nlc3MgZHluYW1pYyByb3V0ZXMgcHJvcGVybHlcbiAgICAvLyBUT0RPOiBmaXggdHVyYm9wYWNrIHByb3ZpZGluZyBkaWZmZXJpbmcgdmFsdWUgZnJvbSB3ZWJwYWNrXG4gICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBzcmNQYWdlID0gc3JjUGFnZS5yZXBsYWNlKC9cXC9pbmRleCQvLCAnJykgfHwgJy8nO1xuICAgIH1cbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlXG4gICAgfSk7XG4gICAgaWYgKCFwcmVwYXJlUmVzdWx0KSB7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDAwO1xuICAgICAgICByZXMuZW5kKCdCYWQgUmVxdWVzdCcpO1xuICAgICAgICBjdHgud2FpdFVudGlsID09IG51bGwgPyB2b2lkIDAgOiBjdHgud2FpdFVudGlsLmNhbGwoY3R4LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBxdWVyeSwgcGFyYW1zLCBwcmVyZW5kZXJNYW5pZmVzdCB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICAgICAgY29uc3Qgb25SZXF1ZXN0RXJyb3IgPSByb3V0ZU1vZHVsZS5pbnN0cnVtZW50YXRpb25PblJlcXVlc3RFcnJvci5iaW5kKHJvdXRlTW9kdWxlKTtcbiAgICAgICAgY29uc3QgaW52b2tlUm91dGVNb2R1bGUgPSBhc3luYyAoc3Bhbik9PnJvdXRlTW9kdWxlLnJlbmRlcihyZXEsIHJlcywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkUmV2YWxpZGF0ZUhlYWRlcktleXM6IHByb2Nlc3MuZW52Ll9fTkVYVF9BTExPV0VEX1JFVkFMSURBVEVfSEVBREVSUyxcbiAgICAgICAgICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGU6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERSksXG4gICAgICAgICAgICAgICAgdHJ1c3RIb3N0SGVhZGVyOiBwcm9jZXNzLmVudi5fX05FWFRfVFJVU1RfSE9TVF9IRUFERVIsXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHRoaXMgZnJvbSBmcm9tIHJ1bnRpbWUgZW52IHNvIG1hbmlmZXN0XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBuZWVkIHRvIGxvYWRcbiAgICAgICAgICAgICAgICBwcmV2aWV3UHJvcHM6IHByZXJlbmRlck1hbmlmZXN0LnByZXZpZXcsXG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRldjogcm91dGVNb2R1bGUuaXNEZXYsXG4gICAgICAgICAgICAgICAgcGFnZTogXCIvYXBpL3BvbGwtc3VibWlzc2lvbnNcIixcbiAgICAgICAgICAgICAgICBwcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogKC4uLmFyZ3MpPT5vblJlcXVlc3RFcnJvcihyZXEsIC4uLmFyZ3MpXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpbnZva2VSb3V0ZU1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIHJlLXRocm93IGluIGRldiB0byBzaG93IHRoZSBlcnJvciBvdmVybGF5XG4gICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gaW52YXJpYW50IGFzIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIHNob3VsZCBiZSBkb25lIGluc2lkZSBvZiBhcGktcmVzb2x2ZXIgb25FcnJvclxuICAgICAgICBzZW5kRXJyb3IocmVzLCA1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGFueSB3YWl0VW50aWwgd29yayBpbiBwYWdlcyBBUEkgcm91dGVzIGN1cnJlbnRseVxuICAgICAgICAvLyBzbyBpZiBjYWxsYmFjayBpcyBwcmVzZW50IHJldHVybiB3aXRoIHJlc29sdmVkIHByb21pc2Ugc2luY2Ugbm9cbiAgICAgICAgLy8gcGVuZGluZyB3b3JrXG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fpoll-submissions&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cpoll-submissions.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/checkSolvesLogic.ts":
/*!***************************************!*\
  !*** ./pages/api/checkSolvesLogic.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkSolvesLogic: () => (/* binding */ checkSolvesLogic)\n/* harmony export */ });\n// src/lib/checkSolvesLogic.ts\nasync function checkSolvesLogic(problems, players) {\n    const problemKey = (p)=>`${p.contestId}-${p.index}`;\n    const trackedProblems = new Set(problems.map(problemKey));\n    console.log(\"Prob: \", trackedProblems);\n    // Map: problemKey -> { team: string, submissionId: number, time: number }\n    const claims = {};\n    // console.log(\"players: \", players)\n    for (const player of players){\n        try {\n            const res = await fetch(`https://codeforces.com/api/user.status?handle=${player.handle}&from=1&count=10`);\n            const data = await res.json();\n            if (data.status !== 'OK') continue;\n            // console.log(player)\n            // console.log('subs: ', data)\n            // console.log('problems: ', trackedProblems)\n            const submissions = data.result;\n            for (const sub of submissions){\n                if (sub.verdict !== 'OK') continue;\n                const key = `${sub.problem.contestId}-${sub.problem.index}`;\n                if (!trackedProblems.has(key)) continue;\n                const existing = claims[key];\n                if (!existing || sub.id < existing.id) {\n                    claims[key] = {\n                        team: player.team,\n                        time: sub.creationTimeSeconds,\n                        id: sub.id\n                    };\n                }\n            }\n        // console.log('here we gooooo: ', claims)\n        } catch (err) {\n            console.error(`Error fetching for ${player.handle}`, err);\n        }\n    }\n    // Final map: problemKey -> teamColor\n    const result = {};\n    for (const [key, claim] of Object.entries(claims)){\n        result[key] = claim.team;\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9jaGVja1NvbHZlc0xvZ2ljLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw4QkFBOEI7QUFZdkIsZUFBZUEsaUJBQWlCQyxRQUFtQixFQUFFQyxPQUFpQjtJQUMzRSxNQUFNQyxhQUFhLENBQUNDLElBQWUsR0FBR0EsRUFBRUMsU0FBUyxDQUFDLENBQUMsRUFBRUQsRUFBRUUsS0FBSyxFQUFFO0lBQzlELE1BQU1DLGtCQUFrQixJQUFJQyxJQUFJUCxTQUFTUSxHQUFHLENBQUNOO0lBQzdDTyxRQUFRQyxHQUFHLENBQUMsVUFBVUo7SUFFdEIsMEVBQTBFO0lBQzFFLE1BQU1LLFNBQXFFLENBQUM7SUFDNUUsb0NBQW9DO0lBQ3BDLEtBQUssTUFBTUMsVUFBVVgsUUFBUztRQUM1QixJQUFJO1lBQ0YsTUFBTVksTUFBTSxNQUFNQyxNQUFNLENBQUMsOENBQThDLEVBQUVGLE9BQU9HLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztZQUN4RyxNQUFNQyxPQUFPLE1BQU1ILElBQUlJLElBQUk7WUFDM0IsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLE1BQU07WUFDMUIsc0JBQXNCO1lBQ3RCLDhCQUE4QjtZQUM5Qiw2Q0FBNkM7WUFDN0MsTUFBTUMsY0FBY0gsS0FBS0ksTUFBTTtZQU8vQixLQUFLLE1BQU1DLE9BQU9GLFlBQWE7Z0JBQzdCLElBQUlFLElBQUlDLE9BQU8sS0FBSyxNQUFNO2dCQUMxQixNQUFNQyxNQUFNLEdBQUdGLElBQUlHLE9BQU8sQ0FBQ3BCLFNBQVMsQ0FBQyxDQUFDLEVBQUVpQixJQUFJRyxPQUFPLENBQUNuQixLQUFLLEVBQUU7Z0JBQzNELElBQUksQ0FBQ0MsZ0JBQWdCbUIsR0FBRyxDQUFDRixNQUFNO2dCQUUvQixNQUFNRyxXQUFXZixNQUFNLENBQUNZLElBQUk7Z0JBQzVCLElBQ0UsQ0FBQ0csWUFDREwsSUFBSU0sRUFBRSxHQUFHRCxTQUFTQyxFQUFFLEVBQ3BCO29CQUNBaEIsTUFBTSxDQUFDWSxJQUFJLEdBQUc7d0JBQ1pLLE1BQU1oQixPQUFPZ0IsSUFBSTt3QkFDakJDLE1BQU1SLElBQUlTLG1CQUFtQjt3QkFDN0JILElBQUlOLElBQUlNLEVBQUU7b0JBQ1o7Z0JBQ0Y7WUFDRjtRQUNBLDBDQUEwQztRQUM1QyxFQUFFLE9BQU9JLEtBQUs7WUFDWnRCLFFBQVF1QixLQUFLLENBQUMsQ0FBQyxtQkFBbUIsRUFBRXBCLE9BQU9HLE1BQU0sRUFBRSxFQUFFZ0I7UUFDdkQ7SUFDRjtJQUVBLHFDQUFxQztJQUNyQyxNQUFNWCxTQUFpQyxDQUFDO0lBQ3hDLEtBQUssTUFBTSxDQUFDRyxLQUFLVSxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ3hCLFFBQVM7UUFDakRTLE1BQU0sQ0FBQ0csSUFBSSxHQUFHVSxNQUFNTCxJQUFJO0lBQzFCO0lBRUEsT0FBT1I7QUFDVCIsInNvdXJjZXMiOlsiRDpcXGJpbmdvLWNwXFxiaW5nby1jcFxcYmluZ28tY3BcXHBhZ2VzXFxhcGlcXGNoZWNrU29sdmVzTG9naWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9jaGVja1NvbHZlc0xvZ2ljLnRzXG5cbmV4cG9ydCB0eXBlIFByb2JsZW0gPSB7XG4gIGNvbnRlc3RJZDogbnVtYmVyXG4gIGluZGV4OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUGxheWVyID0ge1xuICBoYW5kbGU6IHN0cmluZ1xuICB0ZWFtOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrU29sdmVzTG9naWMocHJvYmxlbXM6IFByb2JsZW1bXSwgcGxheWVyczogUGxheWVyW10pIHtcbiAgY29uc3QgcHJvYmxlbUtleSA9IChwOiBQcm9ibGVtKSA9PiBgJHtwLmNvbnRlc3RJZH0tJHtwLmluZGV4fWBcbiAgY29uc3QgdHJhY2tlZFByb2JsZW1zID0gbmV3IFNldChwcm9ibGVtcy5tYXAocHJvYmxlbUtleSkpXG4gIGNvbnNvbGUubG9nKFwiUHJvYjogXCIsIHRyYWNrZWRQcm9ibGVtcyk7XG5cbiAgLy8gTWFwOiBwcm9ibGVtS2V5IC0+IHsgdGVhbTogc3RyaW5nLCBzdWJtaXNzaW9uSWQ6IG51bWJlciwgdGltZTogbnVtYmVyIH1cbiAgY29uc3QgY2xhaW1zOiBSZWNvcmQ8c3RyaW5nLCB7IHRlYW06IHN0cmluZzsgdGltZTogbnVtYmVyOyBpZDogbnVtYmVyIH0+ID0ge31cbiAgLy8gY29uc29sZS5sb2coXCJwbGF5ZXJzOiBcIiwgcGxheWVycylcbiAgZm9yIChjb25zdCBwbGF5ZXIgb2YgcGxheWVycykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9hcGkvdXNlci5zdGF0dXM/aGFuZGxlPSR7cGxheWVyLmhhbmRsZX0mZnJvbT0xJmNvdW50PTEwYClcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG4gICAgICBpZiAoZGF0YS5zdGF0dXMgIT09ICdPSycpIGNvbnRpbnVlXG4gICAgICAvLyBjb25zb2xlLmxvZyhwbGF5ZXIpXG4gICAgICAvLyBjb25zb2xlLmxvZygnc3ViczogJywgZGF0YSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdwcm9ibGVtczogJywgdHJhY2tlZFByb2JsZW1zKVxuICAgICAgY29uc3Qgc3VibWlzc2lvbnMgPSBkYXRhLnJlc3VsdCBhcyBBcnJheTx7XG4gICAgICAgIGlkOiBudW1iZXIsXG4gICAgICAgIGNyZWF0aW9uVGltZVNlY29uZHM6IG51bWJlcixcbiAgICAgICAgcHJvYmxlbTogeyBjb250ZXN0SWQ6IG51bWJlcjsgaW5kZXg6IHN0cmluZyB9LFxuICAgICAgICB2ZXJkaWN0OiBzdHJpbmdcbiAgICAgIH0+XG5cbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHN1Ym1pc3Npb25zKSB7XG4gICAgICAgIGlmIChzdWIudmVyZGljdCAhPT0gJ09LJykgY29udGludWVcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7c3ViLnByb2JsZW0uY29udGVzdElkfS0ke3N1Yi5wcm9ibGVtLmluZGV4fWBcbiAgICAgICAgaWYgKCF0cmFja2VkUHJvYmxlbXMuaGFzKGtleSkpIGNvbnRpbnVlXG5cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjbGFpbXNba2V5XVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWV4aXN0aW5nIHx8XG4gICAgICAgICAgc3ViLmlkIDwgZXhpc3RpbmcuaWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2xhaW1zW2tleV0gPSB7XG4gICAgICAgICAgICB0ZWFtOiBwbGF5ZXIudGVhbSxcbiAgICAgICAgICAgIHRpbWU6IHN1Yi5jcmVhdGlvblRpbWVTZWNvbmRzLFxuICAgICAgICAgICAgaWQ6IHN1Yi5pZCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXJlIHdlIGdvb29vbzogJywgY2xhaW1zKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZm9yICR7cGxheWVyLmhhbmRsZX1gLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWwgbWFwOiBwcm9ibGVtS2V5IC0+IHRlYW1Db2xvclxuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGNvbnN0IFtrZXksIGNsYWltXSBvZiBPYmplY3QuZW50cmllcyhjbGFpbXMpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBjbGFpbS50ZWFtXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiY2hlY2tTb2x2ZXNMb2dpYyIsInByb2JsZW1zIiwicGxheWVycyIsInByb2JsZW1LZXkiLCJwIiwiY29udGVzdElkIiwiaW5kZXgiLCJ0cmFja2VkUHJvYmxlbXMiLCJTZXQiLCJtYXAiLCJjb25zb2xlIiwibG9nIiwiY2xhaW1zIiwicGxheWVyIiwicmVzIiwiZmV0Y2giLCJoYW5kbGUiLCJkYXRhIiwianNvbiIsInN0YXR1cyIsInN1Ym1pc3Npb25zIiwicmVzdWx0Iiwic3ViIiwidmVyZGljdCIsImtleSIsInByb2JsZW0iLCJoYXMiLCJleGlzdGluZyIsImlkIiwidGVhbSIsInRpbWUiLCJjcmVhdGlvblRpbWVTZWNvbmRzIiwiZXJyIiwiZXJyb3IiLCJjbGFpbSIsIk9iamVjdCIsImVudHJpZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/checkSolvesLogic.ts\n");

/***/ }),

/***/ "(api-node)/./pages/api/checkSolvesLogicIOI.ts":
/*!******************************************!*\
  !*** ./pages/api/checkSolvesLogicIOI.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkSolvesLogicIOI: () => (/* binding */ checkSolvesLogicIOI)\n/* harmony export */ });\n// checkSolvesLogicIOI.ts\n// IMPORTANT: adapt fetchSubmissionsForHandle to your API if needed\n// NOTE: added optional `problemIndex` param for compatibility (not required)\nasync function fetchSubmissionsForHandle(handle, problemIndex) {\n    const API_BASE = process.env.DMOJ_API_BASE ?? \"https://dmoj.ca/api/v2\";\n    const API_TOKEN = process.env.DMOJ_API_TOKEN ?? \"\";\n    const headers = {\n        Accept: \"application/json\"\n    };\n    if (API_TOKEN) headers[\"Authorization\"] = `Bearer ${API_TOKEN}`;\n    // Try a couple shapes commonly used\n    const url = `https://dmoj.ca/api/v2/submissions?username=${handle}&problem=joi13op3`;\n    try {\n        const r = await fetch(url, {\n            headers\n        });\n        // console.log(\"NG\")\n        if (!r.ok) return r;\n        const j = await r.json();\n        const arr = j.submissions ?? j.results ?? j.data ?? j;\n        if (Array.isArray(arr)) return arr;\n    } catch (e) {\n    // try next\n    }\n    return [];\n}\n/** normalize a submission's problem identity to key string like \"contestId-index\" */ function submissionProblemKey(sub) {\n    const prob = sub.problem ?? sub.problem_info ?? sub.problem_id ?? sub.task ?? null;\n    let contest = null, index = null;\n    if (prob) {\n        contest = prob.contest ?? prob.contest_id ?? prob.contestId ?? prob.problemset ?? prob.set;\n        index = prob.index ?? prob.code ?? prob.problem_code ?? prob.alias;\n    } else {\n        contest = sub.contest ?? sub.contest_id ?? sub.contestId;\n        index = sub.index ?? sub.code ?? sub.problem_code;\n    }\n    if (!contest || !index) return null;\n    return `${contest}-${index}`;\n}\n/** get numeric score and timestamp (seconds) from a submission */ function parseSubScoreAndTs(sub) {\n    const score = typeof sub.score === \"number\" ? sub.score : typeof sub.points === \"number\" ? sub.points : typeof sub.judge_score === \"number\" ? sub.judge_score : null;\n    const verdict = (sub.verdict ?? sub.result ?? sub.status ?? \"\").toString().toLowerCase();\n    let numericScore = 0;\n    if (score !== null) numericScore = score;\n    else if (verdict === \"ac\" || verdict === \"ok\" || verdict.includes(\"accepted\")) numericScore = sub.maxPoints ?? sub.max_points ?? 100;\n    // timestamp: massage different names\n    let ts = 0;\n    if (typeof sub.creationTimeSeconds === \"number\") ts = sub.creationTimeSeconds;\n    else if (typeof sub.timestamp === \"number\") ts = sub.timestamp;\n    else if (sub.timestamp) ts = Math.floor(new Date(sub.timestamp).getTime() / 1000);\n    else if (sub.created_at) ts = Math.floor(new Date(sub.created_at).getTime() / 1000);\n    return {\n        numericScore,\n        ts\n    };\n}\n/** Robust check whether a submission corresponds to a Problem object\r\n *  Handles shapes like:\r\n *   - submission.problem = { contest: 'ioi08', index: 'p3' }\r\n *   - submission.problem = 'ioi08p3' (string)\r\n *   - top-level fields like submission.code, submission.problem_code\r\n */ function submissionMatchesProblem(sub, problem) {\n    // Desired key in dash form e.g. \"ioi08-p3\"\n    const wantedDashKey = `${String(problem.contestId)}-${String(problem.index)}`.toLowerCase();\n    // Also canonical without dash e.g. \"ioi08p3\"\n    const wantedFlatKey = `${String(problem.contestId)}${String(problem.index)}`.toLowerCase();\n    // 1) Try structured key\n    const dashKey = submissionProblemKey(sub);\n    if (dashKey && String(dashKey).toLowerCase() === wantedDashKey) return true;\n    // 2) Try if submission contains string code forms\n    const subProb = sub.problem ?? sub.problem_info ?? null;\n    const candidates = [];\n    if (typeof subProb === \"string\") candidates.push(subProb);\n    else if (subProb && typeof subProb === \"object\") {\n        candidates.push(String(subProb.code ?? subProb.alias ?? subProb.problem_code ?? \"\"));\n    }\n    // top-level possibilities\n    candidates.push(String(sub.problem_code ?? sub.code ?? sub.task_code ?? sub.alias ?? \"\"));\n    for (const c of candidates){\n        if (!c) continue;\n        const s = String(c).toLowerCase();\n        if (s === wantedFlatKey || s === wantedDashKey.replace('-', '') || s === wantedDashKey) return true;\n        // some instances include punctuation; strip non-alphanumerics and compare\n        const stripped = s.replace(/[^a-z0-9]/g, '');\n        if (stripped === wantedFlatKey.replace(/[^a-z0-9]/g, '')) return true;\n    }\n    return false;\n}\n/**\r\n * problems: list of problems to evaluate (contestId/index)\r\n * players: list of players (handle + team)\r\n * matchStartISO: ISO string of match start (only submissions >= this are considered)\r\n * matchEndISO: optional ISO string of match end (only submissions <= this are considered)\r\n */ async function checkSolvesLogicIOI(problems, players, matchStartISO, matchEndISO) {\n    const matchStartTs = Math.floor(new Date(matchStartISO).getTime() / 1000);\n    const matchEndTs = matchEndISO ? Math.floor(new Date(matchEndISO).getTime() / 1000) : Number.MAX_SAFE_INTEGER;\n    // best score per user per problem during match\n    const bestPerUser = {};\n    console.log(\"PPPPP: \", players.length);\n    console.log(\"PPPPPS: \", problems.length);\n    // iterate problems -> players -> submissions (per your requested flow)\n    for (const problem of problems){\n        const key = `${problem.contestId}-${problem.index}`; // e.g. 'ioi08-p3'\n        for (const player of players){\n            try {\n                // fetch all submissions for handle (we pass problem.index as optional hint; fetch function may ignore it)\n                const subs = await fetchSubmissionsForHandle(player.handle, problem.index);\n                console.log(\"OH NO\", subs);\n                if (!Array.isArray(subs) || subs.length === 0) continue;\n                console.log(\"SSSSSS: \", subs);\n                for (const sub of subs){\n                    // first, check if this submission refers to the current problem\n                    if (!submissionMatchesProblem(sub, problem)) continue;\n                    // parse timestamp & score\n                    const { numericScore, ts } = parseSubScoreAndTs(sub);\n                    if (!ts || ts < matchStartTs || ts > matchEndTs) continue; // only count submissions inside match window\n                    if (!numericScore || numericScore <= 0) continue; // ignore zero-score submissions\n                    // record into bestPerUser\n                    bestPerUser[player.handle] ??= {};\n                    const prev = bestPerUser[player.handle][key];\n                    // For IOI: prefer larger score. If equal, prefer earlier timestamp (smaller ts).\n                    if (!prev || numericScore > prev.score || numericScore === prev.score && ts < prev.timestamp) {\n                        bestPerUser[player.handle][key] = {\n                            score: numericScore,\n                            timestamp: ts\n                        };\n                    }\n                }\n            } catch (err) {\n                // keep going with other players/problems even if one fetch fails\n                console.error(\"fetch error for handle\", player.handle, \"problem\", key, err);\n            }\n        }\n    }\n    // Convert to best team-per-problem using IOI rules (score higher wins; tie -> earlier timestamp)\n    const bestPerProblem = {};\n    for (const problem of problems){\n        const key = `${problem.contestId}-${problem.index}`;\n        let bestScore = -Infinity;\n        let bestTeam = null;\n        let bestTs = Number.MAX_SAFE_INTEGER;\n        let bestHandle;\n        for (const player of players){\n            const userBest = bestPerUser[player.handle]?.[key];\n            if (!userBest) continue;\n            const s = userBest.score;\n            const ts = userBest.timestamp;\n            if (s > bestScore || s === bestScore && ts < bestTs) {\n                bestScore = s;\n                bestTeam = player.team;\n                bestTs = ts;\n                bestHandle = player.handle;\n            }\n        }\n        if (bestTeam !== null && bestScore > 0) {\n            bestPerProblem[key] = {\n                team: bestTeam,\n                score: bestScore,\n                timestamp: new Date(bestTs * 1000).toISOString(),\n                handle: bestHandle\n            };\n        }\n    }\n    return bestPerProblem;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9jaGVja1NvbHZlc0xvZ2ljSU9JLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5QkFBeUI7QUFJekIsbUVBQW1FO0FBQ25FLDZFQUE2RTtBQUM3RSxlQUFlQSwwQkFBMEJDLE1BQWMsRUFBRUMsWUFBcUI7SUFDNUUsTUFBTUMsV0FBV0MsUUFBUUMsR0FBRyxDQUFDQyxhQUFhLElBQUk7SUFDOUMsTUFBTUMsWUFBWUgsUUFBUUMsR0FBRyxDQUFDRyxjQUFjLElBQUk7SUFFaEQsTUFBTUMsVUFBa0M7UUFBRUMsUUFBUTtJQUFtQjtJQUNyRSxJQUFJSCxXQUFXRSxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEVBQUVGLFdBQVc7SUFFL0Qsb0NBQW9DO0lBQ3BDLE1BQU1JLE1BQU0sQ0FBQyw0Q0FBNEMsRUFBRVYsT0FBTyxpQkFBaUIsQ0FBQztJQUNwRixJQUFJO1FBQ0YsTUFBTVcsSUFBSSxNQUFNQyxNQUFNRixLQUFLO1lBQUVGO1FBQVE7UUFDckMsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQ0csRUFBRUUsRUFBRSxFQUFFLE9BQU9GO1FBQ2xCLE1BQU1HLElBQUksTUFBTUgsRUFBRUksSUFBSTtRQUN0QixNQUFNQyxNQUFNRixFQUFFRyxXQUFXLElBQUlILEVBQUVJLE9BQU8sSUFBSUosRUFBRUssSUFBSSxJQUFJTDtRQUNwRCxJQUFJTSxNQUFNQyxPQUFPLENBQUNMLE1BQU0sT0FBT0E7SUFDakMsRUFBRSxPQUFPTSxHQUFHO0lBQ1YsV0FBVztJQUNiO0lBQ0EsT0FBTyxFQUFFO0FBQ1g7QUFFQSxtRkFBbUYsR0FDbkYsU0FBU0MscUJBQXFCQyxHQUFRO0lBQ3BDLE1BQU1DLE9BQU9ELElBQUlFLE9BQU8sSUFBSUYsSUFBSUcsWUFBWSxJQUFJSCxJQUFJSSxVQUFVLElBQUlKLElBQUlLLElBQUksSUFBSTtJQUM5RSxJQUFJQyxVQUFVLE1BQU1DLFFBQVE7SUFDNUIsSUFBSU4sTUFBTTtRQUNSSyxVQUFVTCxLQUFLSyxPQUFPLElBQUlMLEtBQUtPLFVBQVUsSUFBSVAsS0FBS1EsU0FBUyxJQUFJUixLQUFLUyxVQUFVLElBQUlULEtBQUtVLEdBQUc7UUFDMUZKLFFBQVFOLEtBQUtNLEtBQUssSUFBSU4sS0FBS1csSUFBSSxJQUFJWCxLQUFLWSxZQUFZLElBQUlaLEtBQUthLEtBQUs7SUFDcEUsT0FBTztRQUNMUixVQUFVTixJQUFJTSxPQUFPLElBQUlOLElBQUlRLFVBQVUsSUFBSVIsSUFBSVMsU0FBUztRQUN4REYsUUFBUVAsSUFBSU8sS0FBSyxJQUFJUCxJQUFJWSxJQUFJLElBQUlaLElBQUlhLFlBQVk7SUFDbkQ7SUFDQSxJQUFJLENBQUNQLFdBQVcsQ0FBQ0MsT0FBTyxPQUFPO0lBQy9CLE9BQU8sR0FBR0QsUUFBUSxDQUFDLEVBQUVDLE9BQU87QUFDOUI7QUFFQSxnRUFBZ0UsR0FDaEUsU0FBU1EsbUJBQW1CZixHQUFRO0lBQ2xDLE1BQU1nQixRQUNILE9BQU9oQixJQUFJZ0IsS0FBSyxLQUFLLFdBQVdoQixJQUFJZ0IsS0FBSyxHQUN6QyxPQUFPaEIsSUFBSWlCLE1BQU0sS0FBSyxXQUFXakIsSUFBSWlCLE1BQU0sR0FDM0MsT0FBT2pCLElBQUlrQixXQUFXLEtBQUssV0FBV2xCLElBQUlrQixXQUFXLEdBQUc7SUFFM0QsTUFBTUMsVUFBVSxDQUFDbkIsSUFBSW1CLE9BQU8sSUFBSW5CLElBQUlvQixNQUFNLElBQUlwQixJQUFJcUIsTUFBTSxJQUFJLEVBQUMsRUFBR0MsUUFBUSxHQUFHQyxXQUFXO0lBRXRGLElBQUlDLGVBQWU7SUFDbkIsSUFBSVIsVUFBVSxNQUFNUSxlQUFlUjtTQUM5QixJQUFJRyxZQUFZLFFBQVFBLFlBQVksUUFBUUEsUUFBUU0sUUFBUSxDQUFDLGFBQWFELGVBQWV4QixJQUFJMEIsU0FBUyxJQUFJMUIsSUFBSTJCLFVBQVUsSUFBSTtJQUVqSSxxQ0FBcUM7SUFDckMsSUFBSUMsS0FBSztJQUNULElBQUksT0FBTzVCLElBQUk2QixtQkFBbUIsS0FBSyxVQUFVRCxLQUFLNUIsSUFBSTZCLG1CQUFtQjtTQUN4RSxJQUFJLE9BQU83QixJQUFJOEIsU0FBUyxLQUFLLFVBQVVGLEtBQUs1QixJQUFJOEIsU0FBUztTQUN6RCxJQUFJOUIsSUFBSThCLFNBQVMsRUFBRUYsS0FBS0csS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUtqQyxJQUFJOEIsU0FBUyxFQUFFSSxPQUFPLEtBQUs7U0FDdkUsSUFBSWxDLElBQUltQyxVQUFVLEVBQUVQLEtBQUtHLEtBQUtDLEtBQUssQ0FBQyxJQUFJQyxLQUFLakMsSUFBSW1DLFVBQVUsRUFBRUQsT0FBTyxLQUFLO0lBRTlFLE9BQU87UUFBRVY7UUFBY0k7SUFBRztBQUM1QjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1EseUJBQXlCcEMsR0FBUSxFQUFFRSxPQUFnQjtJQUMxRCwyQ0FBMkM7SUFDM0MsTUFBTW1DLGdCQUFnQixHQUFHQyxPQUFPcEMsUUFBUU8sU0FBUyxFQUFFLENBQUMsRUFBRTZCLE9BQU9wQyxRQUFRSyxLQUFLLEdBQUcsQ0FBQ2dCLFdBQVc7SUFDekYsNkNBQTZDO0lBQzdDLE1BQU1nQixnQkFBZ0IsR0FBR0QsT0FBT3BDLFFBQVFPLFNBQVMsSUFBSTZCLE9BQU9wQyxRQUFRSyxLQUFLLEdBQUcsQ0FBQ2dCLFdBQVc7SUFFeEYsd0JBQXdCO0lBQ3hCLE1BQU1pQixVQUFVekMscUJBQXFCQztJQUNyQyxJQUFJd0MsV0FBV0YsT0FBT0UsU0FBU2pCLFdBQVcsT0FBT2MsZUFBZSxPQUFPO0lBRXZFLGtEQUFrRDtJQUNsRCxNQUFNSSxVQUFVekMsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxZQUFZLElBQUk7SUFDbkQsTUFBTXVDLGFBQXVCLEVBQUU7SUFFL0IsSUFBSSxPQUFPRCxZQUFZLFVBQVVDLFdBQVdDLElBQUksQ0FBQ0Y7U0FDNUMsSUFBSUEsV0FBVyxPQUFPQSxZQUFZLFVBQVU7UUFDL0NDLFdBQVdDLElBQUksQ0FBQ0wsT0FBT0csUUFBUTdCLElBQUksSUFBSTZCLFFBQVEzQixLQUFLLElBQUkyQixRQUFRNUIsWUFBWSxJQUFJO0lBQ2xGO0lBRUEsMEJBQTBCO0lBQzFCNkIsV0FBV0MsSUFBSSxDQUFDTCxPQUFPdEMsSUFBSWEsWUFBWSxJQUFJYixJQUFJWSxJQUFJLElBQUlaLElBQUk0QyxTQUFTLElBQUk1QyxJQUFJYyxLQUFLLElBQUk7SUFFckYsS0FBSyxNQUFNK0IsS0FBS0gsV0FBWTtRQUMxQixJQUFJLENBQUNHLEdBQUc7UUFDUixNQUFNQyxJQUFJUixPQUFPTyxHQUFHdEIsV0FBVztRQUMvQixJQUFJdUIsTUFBTVAsaUJBQWlCTyxNQUFNVCxjQUFjVSxPQUFPLENBQUMsS0FBSyxPQUFPRCxNQUFNVCxlQUFlLE9BQU87UUFDL0YsMEVBQTBFO1FBQzFFLE1BQU1XLFdBQVdGLEVBQUVDLE9BQU8sQ0FBQyxjQUFjO1FBQ3pDLElBQUlDLGFBQWFULGNBQWNRLE9BQU8sQ0FBQyxjQUFjLEtBQUssT0FBTztJQUNuRTtJQUVBLE9BQU87QUFDVDtBQUVBOzs7OztDQUtDLEdBQ00sZUFBZUUsb0JBQ3BCQyxRQUFtQixFQUNuQkMsT0FBaUIsRUFDakJDLGFBQXFCLEVBQ3JCQyxXQUFvQjtJQUVwQixNQUFNQyxlQUFldkIsS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUttQixlQUFlbEIsT0FBTyxLQUFLO0lBQ3BFLE1BQU1xQixhQUFhRixjQUFjdEIsS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUtvQixhQUFhbkIsT0FBTyxLQUFLLFFBQVFzQixPQUFPQyxnQkFBZ0I7SUFFN0csK0NBQStDO0lBQy9DLE1BQU1DLGNBQW9GLENBQUM7SUFDM0ZDLFFBQVFDLEdBQUcsQ0FBQyxXQUFXVCxRQUFRVSxNQUFNO0lBQ3JDRixRQUFRQyxHQUFHLENBQUMsWUFBWVYsU0FBU1csTUFBTTtJQUN2Qyx1RUFBdUU7SUFDdkUsS0FBSyxNQUFNM0QsV0FBV2dELFNBQVU7UUFDOUIsTUFBTVksTUFBTSxHQUFHNUQsUUFBUU8sU0FBUyxDQUFDLENBQUMsRUFBRVAsUUFBUUssS0FBSyxFQUFFLEVBQUUsa0JBQWtCO1FBQ3ZFLEtBQUssTUFBTXdELFVBQVVaLFFBQVM7WUFDNUIsSUFBSTtnQkFDRiwwR0FBMEc7Z0JBQzFHLE1BQU1hLE9BQU8sTUFBTXpGLDBCQUEwQndGLE9BQU92RixNQUFNLEVBQUUwQixRQUFRSyxLQUFLO2dCQUN6RW9ELFFBQVFDLEdBQUcsQ0FBQyxTQUFTSTtnQkFDckIsSUFBSSxDQUFDcEUsTUFBTUMsT0FBTyxDQUFDbUUsU0FBU0EsS0FBS0gsTUFBTSxLQUFLLEdBQUc7Z0JBQy9DRixRQUFRQyxHQUFHLENBQUMsWUFBWUk7Z0JBRXhCLEtBQUssTUFBTWhFLE9BQU9nRSxLQUFNO29CQUN0QixnRUFBZ0U7b0JBQ2hFLElBQUksQ0FBQzVCLHlCQUF5QnBDLEtBQUtFLFVBQVU7b0JBRTdDLDBCQUEwQjtvQkFDMUIsTUFBTSxFQUFFc0IsWUFBWSxFQUFFSSxFQUFFLEVBQUUsR0FBR2IsbUJBQW1CZjtvQkFDaEQsSUFBSSxDQUFDNEIsTUFBTUEsS0FBSzBCLGdCQUFnQjFCLEtBQUsyQixZQUFZLFVBQVUsNkNBQTZDO29CQUN4RyxJQUFJLENBQUMvQixnQkFBZ0JBLGdCQUFnQixHQUFHLFVBQVUsZ0NBQWdDO29CQUVsRiwwQkFBMEI7b0JBQzFCa0MsV0FBVyxDQUFDSyxPQUFPdkYsTUFBTSxDQUFDLEtBQUssQ0FBQztvQkFDaEMsTUFBTXlGLE9BQU9QLFdBQVcsQ0FBQ0ssT0FBT3ZGLE1BQU0sQ0FBQyxDQUFDc0YsSUFBSTtvQkFDNUMsaUZBQWlGO29CQUNqRixJQUFJLENBQUNHLFFBQVF6QyxlQUFleUMsS0FBS2pELEtBQUssSUFBS1EsaUJBQWlCeUMsS0FBS2pELEtBQUssSUFBSVksS0FBS3FDLEtBQUtuQyxTQUFTLEVBQUc7d0JBQzlGNEIsV0FBVyxDQUFDSyxPQUFPdkYsTUFBTSxDQUFDLENBQUNzRixJQUFJLEdBQUc7NEJBQUU5QyxPQUFPUTs0QkFBY00sV0FBV0Y7d0JBQUc7b0JBQ3pFO2dCQUNGO1lBQ0YsRUFBRSxPQUFPc0MsS0FBSztnQkFDWixpRUFBaUU7Z0JBQ2pFUCxRQUFRUSxLQUFLLENBQUMsMEJBQTBCSixPQUFPdkYsTUFBTSxFQUFFLFdBQVdzRixLQUFLSTtZQUN6RTtRQUNGO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsTUFBTUUsaUJBQXNHLENBQUM7SUFDN0csS0FBSyxNQUFNbEUsV0FBV2dELFNBQVU7UUFDOUIsTUFBTVksTUFBTSxHQUFHNUQsUUFBUU8sU0FBUyxDQUFDLENBQUMsRUFBRVAsUUFBUUssS0FBSyxFQUFFO1FBQ25ELElBQUk4RCxZQUFZLENBQUNDO1FBQ2pCLElBQUlDLFdBQTBCO1FBQzlCLElBQUlDLFNBQVNoQixPQUFPQyxnQkFBZ0I7UUFDcEMsSUFBSWdCO1FBRUosS0FBSyxNQUFNVixVQUFVWixRQUFTO1lBQzVCLE1BQU11QixXQUFXaEIsV0FBVyxDQUFDSyxPQUFPdkYsTUFBTSxDQUFDLEVBQUUsQ0FBQ3NGLElBQUk7WUFDbEQsSUFBSSxDQUFDWSxVQUFVO1lBQ2YsTUFBTTVCLElBQUk0QixTQUFTMUQsS0FBSztZQUN4QixNQUFNWSxLQUFLOEMsU0FBUzVDLFNBQVM7WUFDN0IsSUFBSWdCLElBQUl1QixhQUFjdkIsTUFBTXVCLGFBQWF6QyxLQUFLNEMsUUFBUztnQkFDckRILFlBQVl2QjtnQkFDWnlCLFdBQVdSLE9BQU9ZLElBQUk7Z0JBQ3RCSCxTQUFTNUM7Z0JBQ1Q2QyxhQUFhVixPQUFPdkYsTUFBTTtZQUM1QjtRQUNGO1FBRUEsSUFBSStGLGFBQWEsUUFBUUYsWUFBWSxHQUFHO1lBQ3RDRCxjQUFjLENBQUNOLElBQUksR0FBRztnQkFDcEJhLE1BQU1KO2dCQUNOdkQsT0FBT3FEO2dCQUNQdkMsV0FBVyxJQUFJRyxLQUFLdUMsU0FBUyxNQUFNSSxXQUFXO2dCQUM5Q3BHLFFBQVFpRztZQUNWO1FBQ0Y7SUFDRjtJQUVBLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIkQ6XFxiaW5nby1jcFxcYmluZ28tY3BcXGJpbmdvLWNwXFxwYWdlc1xcYXBpXFxjaGVja1NvbHZlc0xvZ2ljSU9JLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNoZWNrU29sdmVzTG9naWNJT0kudHNcclxuZXhwb3J0IHR5cGUgUHJvYmxlbSA9IHsgY29udGVzdElkOiBzdHJpbmcgfCBudW1iZXI7IGluZGV4OiBzdHJpbmc7IG1heFBvaW50cz86IG51bWJlciB9O1xyXG5leHBvcnQgdHlwZSBQbGF5ZXIgPSB7IGhhbmRsZTogc3RyaW5nOyB0ZWFtOiBzdHJpbmcgfTtcclxuXHJcbi8vIElNUE9SVEFOVDogYWRhcHQgZmV0Y2hTdWJtaXNzaW9uc0ZvckhhbmRsZSB0byB5b3VyIEFQSSBpZiBuZWVkZWRcclxuLy8gTk9URTogYWRkZWQgb3B0aW9uYWwgYHByb2JsZW1JbmRleGAgcGFyYW0gZm9yIGNvbXBhdGliaWxpdHkgKG5vdCByZXF1aXJlZClcclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hTdWJtaXNzaW9uc0ZvckhhbmRsZShoYW5kbGU6IHN0cmluZywgcHJvYmxlbUluZGV4Pzogc3RyaW5nKSB7XHJcbiAgY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ETU9KX0FQSV9CQVNFID8/IFwiaHR0cHM6Ly9kbW9qLmNhL2FwaS92MlwiO1xyXG4gIGNvbnN0IEFQSV9UT0tFTiA9IHByb2Nlc3MuZW52LkRNT0pfQVBJX1RPS0VOID8/IFwiXCI7XHJcblxyXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcclxuICBpZiAoQVBJX1RPS0VOKSBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtBUElfVE9LRU59YDtcclxuXHJcbiAgLy8gVHJ5IGEgY291cGxlIHNoYXBlcyBjb21tb25seSB1c2VkXHJcbiAgY29uc3QgdXJsID0gYGh0dHBzOi8vZG1vai5jYS9hcGkvdjIvc3VibWlzc2lvbnM/dXNlcm5hbWU9JHtoYW5kbGV9JnByb2JsZW09am9pMTNvcDNgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHIgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVycyB9KTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiTkdcIilcclxuICAgIGlmICghci5vaykgcmV0dXJuIHI7XHJcbiAgICBjb25zdCBqID0gYXdhaXQgci5qc29uKCk7XHJcbiAgICBjb25zdCBhcnIgPSBqLnN1Ym1pc3Npb25zID8/IGoucmVzdWx0cyA/PyBqLmRhdGEgPz8gajtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gdHJ5IG5leHRcclxuICB9XHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG4vKiogbm9ybWFsaXplIGEgc3VibWlzc2lvbidzIHByb2JsZW0gaWRlbnRpdHkgdG8ga2V5IHN0cmluZyBsaWtlIFwiY29udGVzdElkLWluZGV4XCIgKi9cclxuZnVuY3Rpb24gc3VibWlzc2lvblByb2JsZW1LZXkoc3ViOiBhbnkpIHtcclxuICBjb25zdCBwcm9iID0gc3ViLnByb2JsZW0gPz8gc3ViLnByb2JsZW1faW5mbyA/PyBzdWIucHJvYmxlbV9pZCA/PyBzdWIudGFzayA/PyBudWxsO1xyXG4gIGxldCBjb250ZXN0ID0gbnVsbCwgaW5kZXggPSBudWxsO1xyXG4gIGlmIChwcm9iKSB7XHJcbiAgICBjb250ZXN0ID0gcHJvYi5jb250ZXN0ID8/IHByb2IuY29udGVzdF9pZCA/PyBwcm9iLmNvbnRlc3RJZCA/PyBwcm9iLnByb2JsZW1zZXQgPz8gcHJvYi5zZXQ7XHJcbiAgICBpbmRleCA9IHByb2IuaW5kZXggPz8gcHJvYi5jb2RlID8/IHByb2IucHJvYmxlbV9jb2RlID8/IHByb2IuYWxpYXM7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnRlc3QgPSBzdWIuY29udGVzdCA/PyBzdWIuY29udGVzdF9pZCA/PyBzdWIuY29udGVzdElkO1xyXG4gICAgaW5kZXggPSBzdWIuaW5kZXggPz8gc3ViLmNvZGUgPz8gc3ViLnByb2JsZW1fY29kZTtcclxuICB9XHJcbiAgaWYgKCFjb250ZXN0IHx8ICFpbmRleCkgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIGAke2NvbnRlc3R9LSR7aW5kZXh9YDtcclxufVxyXG5cclxuLyoqIGdldCBudW1lcmljIHNjb3JlIGFuZCB0aW1lc3RhbXAgKHNlY29uZHMpIGZyb20gYSBzdWJtaXNzaW9uICovXHJcbmZ1bmN0aW9uIHBhcnNlU3ViU2NvcmVBbmRUcyhzdWI6IGFueSkge1xyXG4gIGNvbnN0IHNjb3JlID1cclxuICAgICh0eXBlb2Ygc3ViLnNjb3JlID09PSBcIm51bWJlclwiID8gc3ViLnNjb3JlIDpcclxuICAgICB0eXBlb2Ygc3ViLnBvaW50cyA9PT0gXCJudW1iZXJcIiA/IHN1Yi5wb2ludHMgOlxyXG4gICAgIHR5cGVvZiBzdWIuanVkZ2Vfc2NvcmUgPT09IFwibnVtYmVyXCIgPyBzdWIuanVkZ2Vfc2NvcmUgOiBudWxsKTtcclxuXHJcbiAgY29uc3QgdmVyZGljdCA9IChzdWIudmVyZGljdCA/PyBzdWIucmVzdWx0ID8/IHN1Yi5zdGF0dXMgPz8gXCJcIikudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICBsZXQgbnVtZXJpY1Njb3JlID0gMDtcclxuICBpZiAoc2NvcmUgIT09IG51bGwpIG51bWVyaWNTY29yZSA9IHNjb3JlO1xyXG4gIGVsc2UgaWYgKHZlcmRpY3QgPT09IFwiYWNcIiB8fCB2ZXJkaWN0ID09PSBcIm9rXCIgfHwgdmVyZGljdC5pbmNsdWRlcyhcImFjY2VwdGVkXCIpKSBudW1lcmljU2NvcmUgPSBzdWIubWF4UG9pbnRzID8/IHN1Yi5tYXhfcG9pbnRzID8/IDEwMDtcclxuXHJcbiAgLy8gdGltZXN0YW1wOiBtYXNzYWdlIGRpZmZlcmVudCBuYW1lc1xyXG4gIGxldCB0cyA9IDA7XHJcbiAgaWYgKHR5cGVvZiBzdWIuY3JlYXRpb25UaW1lU2Vjb25kcyA9PT0gXCJudW1iZXJcIikgdHMgPSBzdWIuY3JlYXRpb25UaW1lU2Vjb25kcztcclxuICBlbHNlIGlmICh0eXBlb2Ygc3ViLnRpbWVzdGFtcCA9PT0gXCJudW1iZXJcIikgdHMgPSBzdWIudGltZXN0YW1wO1xyXG4gIGVsc2UgaWYgKHN1Yi50aW1lc3RhbXApIHRzID0gTWF0aC5mbG9vcihuZXcgRGF0ZShzdWIudGltZXN0YW1wKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICBlbHNlIGlmIChzdWIuY3JlYXRlZF9hdCkgdHMgPSBNYXRoLmZsb29yKG5ldyBEYXRlKHN1Yi5jcmVhdGVkX2F0KS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuXHJcbiAgcmV0dXJuIHsgbnVtZXJpY1Njb3JlLCB0cyB9O1xyXG59XHJcblxyXG4vKiogUm9idXN0IGNoZWNrIHdoZXRoZXIgYSBzdWJtaXNzaW9uIGNvcnJlc3BvbmRzIHRvIGEgUHJvYmxlbSBvYmplY3RcclxuICogIEhhbmRsZXMgc2hhcGVzIGxpa2U6XHJcbiAqICAgLSBzdWJtaXNzaW9uLnByb2JsZW0gPSB7IGNvbnRlc3Q6ICdpb2kwOCcsIGluZGV4OiAncDMnIH1cclxuICogICAtIHN1Ym1pc3Npb24ucHJvYmxlbSA9ICdpb2kwOHAzJyAoc3RyaW5nKVxyXG4gKiAgIC0gdG9wLWxldmVsIGZpZWxkcyBsaWtlIHN1Ym1pc3Npb24uY29kZSwgc3VibWlzc2lvbi5wcm9ibGVtX2NvZGVcclxuICovXHJcbmZ1bmN0aW9uIHN1Ym1pc3Npb25NYXRjaGVzUHJvYmxlbShzdWI6IGFueSwgcHJvYmxlbTogUHJvYmxlbSk6IGJvb2xlYW4ge1xyXG4gIC8vIERlc2lyZWQga2V5IGluIGRhc2ggZm9ybSBlLmcuIFwiaW9pMDgtcDNcIlxyXG4gIGNvbnN0IHdhbnRlZERhc2hLZXkgPSBgJHtTdHJpbmcocHJvYmxlbS5jb250ZXN0SWQpfS0ke1N0cmluZyhwcm9ibGVtLmluZGV4KX1gLnRvTG93ZXJDYXNlKCk7XHJcbiAgLy8gQWxzbyBjYW5vbmljYWwgd2l0aG91dCBkYXNoIGUuZy4gXCJpb2kwOHAzXCJcclxuICBjb25zdCB3YW50ZWRGbGF0S2V5ID0gYCR7U3RyaW5nKHByb2JsZW0uY29udGVzdElkKX0ke1N0cmluZyhwcm9ibGVtLmluZGV4KX1gLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIC8vIDEpIFRyeSBzdHJ1Y3R1cmVkIGtleVxyXG4gIGNvbnN0IGRhc2hLZXkgPSBzdWJtaXNzaW9uUHJvYmxlbUtleShzdWIpO1xyXG4gIGlmIChkYXNoS2V5ICYmIFN0cmluZyhkYXNoS2V5KS50b0xvd2VyQ2FzZSgpID09PSB3YW50ZWREYXNoS2V5KSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgLy8gMikgVHJ5IGlmIHN1Ym1pc3Npb24gY29udGFpbnMgc3RyaW5nIGNvZGUgZm9ybXNcclxuICBjb25zdCBzdWJQcm9iID0gc3ViLnByb2JsZW0gPz8gc3ViLnByb2JsZW1faW5mbyA/PyBudWxsO1xyXG4gIGNvbnN0IGNhbmRpZGF0ZXM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIGlmICh0eXBlb2Ygc3ViUHJvYiA9PT0gXCJzdHJpbmdcIikgY2FuZGlkYXRlcy5wdXNoKHN1YlByb2IpO1xyXG4gIGVsc2UgaWYgKHN1YlByb2IgJiYgdHlwZW9mIHN1YlByb2IgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGNhbmRpZGF0ZXMucHVzaChTdHJpbmcoc3ViUHJvYi5jb2RlID8/IHN1YlByb2IuYWxpYXMgPz8gc3ViUHJvYi5wcm9ibGVtX2NvZGUgPz8gXCJcIikpO1xyXG4gIH1cclxuXHJcbiAgLy8gdG9wLWxldmVsIHBvc3NpYmlsaXRpZXNcclxuICBjYW5kaWRhdGVzLnB1c2goU3RyaW5nKHN1Yi5wcm9ibGVtX2NvZGUgPz8gc3ViLmNvZGUgPz8gc3ViLnRhc2tfY29kZSA/PyBzdWIuYWxpYXMgPz8gXCJcIikpO1xyXG5cclxuICBmb3IgKGNvbnN0IGMgb2YgY2FuZGlkYXRlcykge1xyXG4gICAgaWYgKCFjKSBjb250aW51ZTtcclxuICAgIGNvbnN0IHMgPSBTdHJpbmcoYykudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChzID09PSB3YW50ZWRGbGF0S2V5IHx8IHMgPT09IHdhbnRlZERhc2hLZXkucmVwbGFjZSgnLScsICcnKSB8fCBzID09PSB3YW50ZWREYXNoS2V5KSByZXR1cm4gdHJ1ZTtcclxuICAgIC8vIHNvbWUgaW5zdGFuY2VzIGluY2x1ZGUgcHVuY3R1YXRpb247IHN0cmlwIG5vbi1hbHBoYW51bWVyaWNzIGFuZCBjb21wYXJlXHJcbiAgICBjb25zdCBzdHJpcHBlZCA9IHMucmVwbGFjZSgvW15hLXowLTldL2csICcnKTtcclxuICAgIGlmIChzdHJpcHBlZCA9PT0gd2FudGVkRmxhdEtleS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJycpKSByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHByb2JsZW1zOiBsaXN0IG9mIHByb2JsZW1zIHRvIGV2YWx1YXRlIChjb250ZXN0SWQvaW5kZXgpXHJcbiAqIHBsYXllcnM6IGxpc3Qgb2YgcGxheWVycyAoaGFuZGxlICsgdGVhbSlcclxuICogbWF0Y2hTdGFydElTTzogSVNPIHN0cmluZyBvZiBtYXRjaCBzdGFydCAob25seSBzdWJtaXNzaW9ucyA+PSB0aGlzIGFyZSBjb25zaWRlcmVkKVxyXG4gKiBtYXRjaEVuZElTTzogb3B0aW9uYWwgSVNPIHN0cmluZyBvZiBtYXRjaCBlbmQgKG9ubHkgc3VibWlzc2lvbnMgPD0gdGhpcyBhcmUgY29uc2lkZXJlZClcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1NvbHZlc0xvZ2ljSU9JKFxyXG4gIHByb2JsZW1zOiBQcm9ibGVtW10sXHJcbiAgcGxheWVyczogUGxheWVyW10sXHJcbiAgbWF0Y2hTdGFydElTTzogc3RyaW5nLFxyXG4gIG1hdGNoRW5kSVNPPzogc3RyaW5nLFxyXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHsgdGVhbTogc3RyaW5nOyBzY29yZTogbnVtYmVyOyB0aW1lc3RhbXA6IHN0cmluZzsgaGFuZGxlPzogc3RyaW5nIH0+PiB7XHJcbiAgY29uc3QgbWF0Y2hTdGFydFRzID0gTWF0aC5mbG9vcihuZXcgRGF0ZShtYXRjaFN0YXJ0SVNPKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICBjb25zdCBtYXRjaEVuZFRzID0gbWF0Y2hFbmRJU08gPyBNYXRoLmZsb29yKG5ldyBEYXRlKG1hdGNoRW5kSVNPKS5nZXRUaW1lKCkgLyAxMDAwKSA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG5cclxuICAvLyBiZXN0IHNjb3JlIHBlciB1c2VyIHBlciBwcm9ibGVtIGR1cmluZyBtYXRjaFxyXG4gIGNvbnN0IGJlc3RQZXJVc2VyOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB7IHNjb3JlOiBudW1iZXI7IHRpbWVzdGFtcDogbnVtYmVyIH0+PiA9IHt9O1xyXG4gIGNvbnNvbGUubG9nKFwiUFBQUFA6IFwiLCBwbGF5ZXJzLmxlbmd0aCk7XHJcbiAgY29uc29sZS5sb2coXCJQUFBQUFM6IFwiLCBwcm9ibGVtcy5sZW5ndGgpO1xyXG4gIC8vIGl0ZXJhdGUgcHJvYmxlbXMgLT4gcGxheWVycyAtPiBzdWJtaXNzaW9ucyAocGVyIHlvdXIgcmVxdWVzdGVkIGZsb3cpXHJcbiAgZm9yIChjb25zdCBwcm9ibGVtIG9mIHByb2JsZW1zKSB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHtwcm9ibGVtLmNvbnRlc3RJZH0tJHtwcm9ibGVtLmluZGV4fWA7IC8vIGUuZy4gJ2lvaTA4LXAzJ1xyXG4gICAgZm9yIChjb25zdCBwbGF5ZXIgb2YgcGxheWVycykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGZldGNoIGFsbCBzdWJtaXNzaW9ucyBmb3IgaGFuZGxlICh3ZSBwYXNzIHByb2JsZW0uaW5kZXggYXMgb3B0aW9uYWwgaGludDsgZmV0Y2ggZnVuY3Rpb24gbWF5IGlnbm9yZSBpdClcclxuICAgICAgICBjb25zdCBzdWJzID0gYXdhaXQgZmV0Y2hTdWJtaXNzaW9uc0ZvckhhbmRsZShwbGF5ZXIuaGFuZGxlLCBwcm9ibGVtLmluZGV4KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk9IIE5PXCIsIHN1YnMpO1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdWJzKSB8fCBzdWJzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTU1NTU1M6IFwiLCBzdWJzKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2Ygc3Vicykge1xyXG4gICAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHRoaXMgc3VibWlzc2lvbiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgcHJvYmxlbVxyXG4gICAgICAgICAgaWYgKCFzdWJtaXNzaW9uTWF0Y2hlc1Byb2JsZW0oc3ViLCBwcm9ibGVtKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgLy8gcGFyc2UgdGltZXN0YW1wICYgc2NvcmVcclxuICAgICAgICAgIGNvbnN0IHsgbnVtZXJpY1Njb3JlLCB0cyB9ID0gcGFyc2VTdWJTY29yZUFuZFRzKHN1Yik7XHJcbiAgICAgICAgICBpZiAoIXRzIHx8IHRzIDwgbWF0Y2hTdGFydFRzIHx8IHRzID4gbWF0Y2hFbmRUcykgY29udGludWU7IC8vIG9ubHkgY291bnQgc3VibWlzc2lvbnMgaW5zaWRlIG1hdGNoIHdpbmRvd1xyXG4gICAgICAgICAgaWYgKCFudW1lcmljU2NvcmUgfHwgbnVtZXJpY1Njb3JlIDw9IDApIGNvbnRpbnVlOyAvLyBpZ25vcmUgemVyby1zY29yZSBzdWJtaXNzaW9uc1xyXG5cclxuICAgICAgICAgIC8vIHJlY29yZCBpbnRvIGJlc3RQZXJVc2VyXHJcbiAgICAgICAgICBiZXN0UGVyVXNlcltwbGF5ZXIuaGFuZGxlXSA/Pz0ge307XHJcbiAgICAgICAgICBjb25zdCBwcmV2ID0gYmVzdFBlclVzZXJbcGxheWVyLmhhbmRsZV1ba2V5XTtcclxuICAgICAgICAgIC8vIEZvciBJT0k6IHByZWZlciBsYXJnZXIgc2NvcmUuIElmIGVxdWFsLCBwcmVmZXIgZWFybGllciB0aW1lc3RhbXAgKHNtYWxsZXIgdHMpLlxyXG4gICAgICAgICAgaWYgKCFwcmV2IHx8IG51bWVyaWNTY29yZSA+IHByZXYuc2NvcmUgfHwgKG51bWVyaWNTY29yZSA9PT0gcHJldi5zY29yZSAmJiB0cyA8IHByZXYudGltZXN0YW1wKSkge1xyXG4gICAgICAgICAgICBiZXN0UGVyVXNlcltwbGF5ZXIuaGFuZGxlXVtrZXldID0geyBzY29yZTogbnVtZXJpY1Njb3JlLCB0aW1lc3RhbXA6IHRzIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAvLyBrZWVwIGdvaW5nIHdpdGggb3RoZXIgcGxheWVycy9wcm9ibGVtcyBldmVuIGlmIG9uZSBmZXRjaCBmYWlsc1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmZXRjaCBlcnJvciBmb3IgaGFuZGxlXCIsIHBsYXllci5oYW5kbGUsIFwicHJvYmxlbVwiLCBrZXksIGVycik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgdG8gYmVzdCB0ZWFtLXBlci1wcm9ibGVtIHVzaW5nIElPSSBydWxlcyAoc2NvcmUgaGlnaGVyIHdpbnM7IHRpZSAtPiBlYXJsaWVyIHRpbWVzdGFtcClcclxuICBjb25zdCBiZXN0UGVyUHJvYmxlbTogUmVjb3JkPHN0cmluZywgeyB0ZWFtOiBzdHJpbmc7IHNjb3JlOiBudW1iZXI7IHRpbWVzdGFtcDogc3RyaW5nOyBoYW5kbGU/OiBzdHJpbmcgfT4gPSB7fTtcclxuICBmb3IgKGNvbnN0IHByb2JsZW0gb2YgcHJvYmxlbXMpIHtcclxuICAgIGNvbnN0IGtleSA9IGAke3Byb2JsZW0uY29udGVzdElkfS0ke3Byb2JsZW0uaW5kZXh9YDtcclxuICAgIGxldCBiZXN0U2NvcmUgPSAtSW5maW5pdHk7XHJcbiAgICBsZXQgYmVzdFRlYW06IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG4gICAgbGV0IGJlc3RUcyA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgbGV0IGJlc3RIYW5kbGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHBsYXllciBvZiBwbGF5ZXJzKSB7XHJcbiAgICAgIGNvbnN0IHVzZXJCZXN0ID0gYmVzdFBlclVzZXJbcGxheWVyLmhhbmRsZV0/LltrZXldO1xyXG4gICAgICBpZiAoIXVzZXJCZXN0KSBjb250aW51ZTtcclxuICAgICAgY29uc3QgcyA9IHVzZXJCZXN0LnNjb3JlO1xyXG4gICAgICBjb25zdCB0cyA9IHVzZXJCZXN0LnRpbWVzdGFtcDtcclxuICAgICAgaWYgKHMgPiBiZXN0U2NvcmUgfHwgKHMgPT09IGJlc3RTY29yZSAmJiB0cyA8IGJlc3RUcykpIHtcclxuICAgICAgICBiZXN0U2NvcmUgPSBzO1xyXG4gICAgICAgIGJlc3RUZWFtID0gcGxheWVyLnRlYW07XHJcbiAgICAgICAgYmVzdFRzID0gdHM7XHJcbiAgICAgICAgYmVzdEhhbmRsZSA9IHBsYXllci5oYW5kbGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmVzdFRlYW0gIT09IG51bGwgJiYgYmVzdFNjb3JlID4gMCkge1xyXG4gICAgICBiZXN0UGVyUHJvYmxlbVtrZXldID0ge1xyXG4gICAgICAgIHRlYW06IGJlc3RUZWFtLFxyXG4gICAgICAgIHNjb3JlOiBiZXN0U2NvcmUsXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShiZXN0VHMgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIGhhbmRsZTogYmVzdEhhbmRsZSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBiZXN0UGVyUHJvYmxlbTtcclxufVxyXG4iXSwibmFtZXMiOlsiZmV0Y2hTdWJtaXNzaW9uc0ZvckhhbmRsZSIsImhhbmRsZSIsInByb2JsZW1JbmRleCIsIkFQSV9CQVNFIiwicHJvY2VzcyIsImVudiIsIkRNT0pfQVBJX0JBU0UiLCJBUElfVE9LRU4iLCJETU9KX0FQSV9UT0tFTiIsImhlYWRlcnMiLCJBY2NlcHQiLCJ1cmwiLCJyIiwiZmV0Y2giLCJvayIsImoiLCJqc29uIiwiYXJyIiwic3VibWlzc2lvbnMiLCJyZXN1bHRzIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImUiLCJzdWJtaXNzaW9uUHJvYmxlbUtleSIsInN1YiIsInByb2IiLCJwcm9ibGVtIiwicHJvYmxlbV9pbmZvIiwicHJvYmxlbV9pZCIsInRhc2siLCJjb250ZXN0IiwiaW5kZXgiLCJjb250ZXN0X2lkIiwiY29udGVzdElkIiwicHJvYmxlbXNldCIsInNldCIsImNvZGUiLCJwcm9ibGVtX2NvZGUiLCJhbGlhcyIsInBhcnNlU3ViU2NvcmVBbmRUcyIsInNjb3JlIiwicG9pbnRzIiwianVkZ2Vfc2NvcmUiLCJ2ZXJkaWN0IiwicmVzdWx0Iiwic3RhdHVzIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIm51bWVyaWNTY29yZSIsImluY2x1ZGVzIiwibWF4UG9pbnRzIiwibWF4X3BvaW50cyIsInRzIiwiY3JlYXRpb25UaW1lU2Vjb25kcyIsInRpbWVzdGFtcCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJnZXRUaW1lIiwiY3JlYXRlZF9hdCIsInN1Ym1pc3Npb25NYXRjaGVzUHJvYmxlbSIsIndhbnRlZERhc2hLZXkiLCJTdHJpbmciLCJ3YW50ZWRGbGF0S2V5IiwiZGFzaEtleSIsInN1YlByb2IiLCJjYW5kaWRhdGVzIiwicHVzaCIsInRhc2tfY29kZSIsImMiLCJzIiwicmVwbGFjZSIsInN0cmlwcGVkIiwiY2hlY2tTb2x2ZXNMb2dpY0lPSSIsInByb2JsZW1zIiwicGxheWVycyIsIm1hdGNoU3RhcnRJU08iLCJtYXRjaEVuZElTTyIsIm1hdGNoU3RhcnRUcyIsIm1hdGNoRW5kVHMiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYmVzdFBlclVzZXIiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwia2V5IiwicGxheWVyIiwic3VicyIsInByZXYiLCJlcnIiLCJlcnJvciIsImJlc3RQZXJQcm9ibGVtIiwiYmVzdFNjb3JlIiwiSW5maW5pdHkiLCJiZXN0VGVhbSIsImJlc3RUcyIsImJlc3RIYW5kbGUiLCJ1c2VyQmVzdCIsInRlYW0iLCJ0b0lTT1N0cmluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/checkSolvesLogicIOI.ts\n");

/***/ }),

/***/ "(api-node)/./pages/api/poll-submissions.ts":
/*!***************************************!*\
  !*** ./pages/api/poll-submissions.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/app/lib/prisma */ \"(api-node)/./src/app/lib/prisma.ts\");\n/* harmony import */ var _checkSolvesLogic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkSolvesLogic */ \"(api-node)/./pages/api/checkSolvesLogic.ts\");\n/* harmony import */ var _checkSolvesLogicIOI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checkSolvesLogicIOI */ \"(api-node)/./pages/api/checkSolvesLogicIOI.ts\");\n\n\n\nasync function fetchReplacementProblem(exclude, minRating, maxRating, handles) {\n    try {\n        const res = await fetch('http://localhost:3000/api/getProblems', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                minRating: minRating ?? 800,\n                maxRating: maxRating ?? 3500,\n                userHandles: handles,\n                // optionally include excludes if you implement that on getProblems\n                // excludeProblems: exclude,\n                count: 1,\n                exculde: exclude\n            })\n        });\n        if (!res.ok) return null;\n        const data = await res.json();\n        // console.log(\"Daa: \", data);\n        return (data.problems && data.problems[0]) ?? null;\n    } catch (err) {\n        console.error('fetchReplacementProblem error', err);\n        return null;\n    }\n}\nasync function handler(req, res) {\n    if (req.method !== 'POST') {\n        return res.status(405).json({\n            error: 'Method Not Allowed'\n        });\n    }\n    // console.log('Request body:', req.body);\n    try {\n        const { matchId } = req.body;\n        if (!matchId) return res.status(400).json({\n            error: 'matchId required'\n        });\n        // console.log('THE IID:', matchId)\n        // console.log('THE REAL STUFF:', req.body)\n        const match = await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.match.findUnique({\n            where: {\n                id: matchId\n            },\n            include: {\n                problems: true,\n                teams: {\n                    include: {\n                        members: true\n                    }\n                },\n                solveLog: {\n                    include: {\n                        problem: true\n                    }\n                }\n            }\n        });\n        // console.log('Created match object:', match);\n        // console.log('DONE2')\n        if (!match) {\n            return res.status(404).json({\n                error: 'Match not found'\n            });\n        }\n        // console.log('DONE3')\n        console.log(\"Match Problems: \", match.problems);\n        const problems = match.problems.filter((p)=>p.active === true).map((p)=>({\n                contestId: p.contestId,\n                index: p.index\n            }));\n        // console.log('THE REAL STUFF:', problems)\n        const players = match.teams.flatMap((team)=>team.members.map((member)=>({\n                    handle: member.handle,\n                    team: team.color\n                })));\n        // compute match window used by IOI logic\n        const matchStart = new Date(match.startTime);\n        const matchEnd = new Date(matchStart.getTime() + match.durationMinutes * 60000);\n        // console.log(\"WHHHHHHHHHHHHAT\");\n        if (match.mode === 'ioi') {\n            // IOI mode: get best scores per problem\n            console.log(\"ALIVE\");\n            const claims = await (0,_checkSolvesLogicIOI__WEBPACK_IMPORTED_MODULE_2__.checkSolvesLogicIOI)(problems, players, matchStart.toISOString(), matchEnd.toISOString());\n            // claims: { '1234-A': { team, score, timestamp, handle } }\n            for (const [key, claim] of Object.entries(claims)){\n                const dash = key.lastIndexOf('-');\n                const contestIdStr = key.slice(0, dash);\n                const index = key.slice(dash + 1);\n                const contestIdNum = Number(contestIdStr);\n                // find existing by comparing as strings to be robust (DB may store numeric or string IDs)\n                const existing = match.solveLog.find((s)=>String(s.contestId) === contestIdStr && s.index === index);\n                if (!existing) {\n                    // create only if score > 0\n                    if ((claim.score ?? 0) > 0) {\n                        await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.solveLog.create({\n                            data: {\n                                matchId: match.id,\n                                contestId: Number.isNaN(contestIdNum) ? 0 : contestIdNum,\n                                index,\n                                team: claim.team,\n                                handle: claim.handle ?? '',\n                                timestamp: new Date(claim.timestamp),\n                                score: claim.score ?? undefined\n                            }\n                        });\n                    }\n                } else {\n                    const oldScore = existing.score ?? 0;\n                    if ((claim.score ?? 0) > oldScore) {\n                        await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.solveLog.update({\n                            where: {\n                                id: existing.id\n                            },\n                            data: {\n                                team: claim.team,\n                                handle: claim.handle ?? existing.handle,\n                                timestamp: new Date(claim.timestamp),\n                                score: claim.score ?? existing.score\n                            }\n                        });\n                    } else if ((claim.score ?? 0) === oldScore) {\n                        // optional: earliest timestamp tie-break\n                        if (new Date(claim.timestamp) < existing.timestamp) {\n                            await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.solveLog.update({\n                                where: {\n                                    id: existing.id\n                                },\n                                data: {\n                                    team: claim.team,\n                                    timestamp: new Date(claim.timestamp),\n                                    handle: claim.handle ?? existing.handle\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        } else {\n            // console.log('ok?')\n            // console.log(\"Prob:: \", problems);\n            const claims = await (0,_checkSolvesLogic__WEBPACK_IMPORTED_MODULE_1__.checkSolvesLogic)(problems, players);\n            // console.log('i guess: ', claims)\n            // Prepare new solves to add\n            // Prepare new solves to add (only those not already in DB)\n            // console.log(\"C: \",claims);\n            const newSolves = [];\n            for (const [key, teamColor] of Object.entries(claims)){\n                const [contestIdStr, index] = key.split('-');\n                const contestId = Number(contestIdStr);\n                // Check if already recorded\n                if (!match.solveLog.some((log)=>log.contestId === contestId && log.index === index)) {\n                    // console.log('i was right!!')\n                    newSolves.push({\n                        handle: '',\n                        team: teamColor,\n                        contestId,\n                        index,\n                        timestamp: new Date(),\n                        matchId: match.id\n                    });\n                }\n            }\n            if (newSolves.length === 0) {\n                // nothing new\n                // return updated:false but include canonical match so client can stay in sync\n                const updatedMatch = await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.match.findUnique({\n                    where: {\n                        id: matchId\n                    },\n                    include: {\n                        problems: {\n                            where: {\n                                active: true\n                            },\n                            orderBy: {\n                                position: 'asc'\n                            }\n                        },\n                        teams: {\n                            include: {\n                                members: true\n                            }\n                        },\n                        solveLog: {\n                            include: {\n                                problem: true\n                            }\n                        }\n                    }\n                });\n                return res.status(200).json({\n                    updated: false,\n                    match: updatedMatch\n                });\n            }\n            // For each new solve: create solve log and (if replace mode) replace the problem atomically\n            //  console.log(\"newSolves: \", newSolves);\n            for (const s of newSolves){\n                const { contestId, index, team } = s;\n                // find the *old* problem row (should exist)\n                // Find the *active* problem row that matches the solved contest/index\n                const solvedRow = await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.problem.findFirst({\n                    where: {\n                        contestId,\n                        index,\n                        matchId,\n                        active: true\n                    }\n                });\n                // If we don't find an active row for this contest/index, try the unique lookup as a fallback\n                const oldProblem = solvedRow ?? await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.problem.findUnique({\n                    where: {\n                        contestId_index_matchId: {\n                            contestId,\n                            index,\n                            matchId\n                        }\n                    }\n                });\n                // const oldProblem = await prisma.problem.findUnique({\n                //   where: { contestId_index_matchId: { contestId: contestId, index: index, matchId } },\n                // });\n                // create the solve log referencing the old problem (so message uses old problem fields)\n                await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.solveLog.create({\n                    data: {\n                        handle: '',\n                        team,\n                        contestId,\n                        index,\n                        timestamp: new Date(),\n                        matchId\n                    }\n                });\n                // If replace mode, atomically deactivate old problem and create a new replacement at same position\n                if (match.mode === 'replace' && oldProblem) {\n                    // compute target rating for replacement\n                    const increment = match.replaceIncrement ?? 100;\n                    const newRatingTarget = Math.min(3500, (oldProblem.rating ?? 0) + increment);\n                    const allHandles = match.teams.flatMap((team)=>team.members).flatMap((p)=>p.handle);\n                    // console.log(\"Inc: \", increment);\n                    // fetch candidate replacement from your problem source (getProblems). We'll ask for 1 problem.\n                    const replacementCandidate = await fetchReplacementProblem(problems.map((p)=>String(p.contestId) + p.index), newRatingTarget, newRatingTarget, allHandles);\n                    // console.log(\"REP: \", replacementCandidate);\n                    console.log('done');\n                    console.log('ProBB:: ', problems);\n                    // Do atomic transaction: deactivate old problem and create new one at same position\n                    await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.$transaction(async (tx)=>{\n                        // mark old problem inactive\n                        await tx.problem.update({\n                            where: {\n                                contestId_index_matchId: {\n                                    contestId: oldProblem.contestId,\n                                    index: oldProblem.index,\n                                    matchId\n                                }\n                            },\n                            data: {\n                                active: false\n                            }\n                        });\n                        // If we found a replacement candidate, create it; otherwise create a placeholder row (you may tweak)\n                        if (replacementCandidate) {\n                            // override rating to newRatingTarget to apply increment rule\n                            await tx.problem.create({\n                                data: {\n                                    contestId: replacementCandidate.contestId ?? 0,\n                                    index: replacementCandidate.index ?? String(Date.now()),\n                                    matchId,\n                                    rating: replacementCandidate?.rating ?? newRatingTarget,\n                                    name: replacementCandidate.name ?? `Problem ${replacementCandidate.index}`,\n                                    position: oldProblem.position,\n                                    active: true\n                                }\n                            });\n                        } else {\n                            // fallback: create a placeholder \"unknown\" problem with computed rating\n                            await tx.problem.create({\n                                data: {\n                                    contestId: 0,\n                                    index: String(Date.now()),\n                                    matchId,\n                                    rating: newRatingTarget,\n                                    name: `Replacement (${newRatingTarget})`,\n                                    position: oldProblem.position,\n                                    active: true\n                                }\n                            });\n                        }\n                    });\n                }\n            }\n        // // Insert new solves if any\n        // if (newSolves.length > 0) {\n        //   await prisma.solveLog.createMany({\n        //     data: newSolves.map(ns => ({\n        //       handle: ns.handle,\n        //       team: ns.team,\n        //       contestId: ns.contestId,\n        //       index: ns.index,\n        //       timestamp: ns.timestamp,\n        //       matchId: ns.matchId,\n        //     }))\n        //   })\n        // }\n        // // ======= Replace logic (if match.mode === 'replace') =======\n        // if (newSolves.length > 0 && match.mode === 'replace') {\n        //   // Prepare list of active problem keys to exclude from replacements\n        //   // only include currently active problems\n        //   const activeProblems = match.problems\n        //     .filter(p => p.active)\n        //     .map(p => `${p.contestId}-${p.index}`)\n        //   // Also add any newly-solved keys so replacements avoid them\n        //   const newlySolvedKeys = newSolves.map(ns => `${ns.contestId}-${ns.index}`)\n        //   activeProblems.push(...newlySolvedKeys)\n        //   // All user handles for exclude checks (same as when creating the match)\n        //   const allHandles = match.teams.flatMap(t => t.members.map(m => m.handle))\n        //   // We'll iterate through newSolves sequentially. For each solved problem:\n        //   for (const solved of newSolves) {\n        //     const solvedKey = `${solved.contestId}-${solved.index}`\n        //     // find the *active* Problem row that matches this contestId/index & matchId\n        //     const oldProblem = match.problems.find(p =>\n        //       p.contestId === solved.contestId &&\n        //       p.index === solved.index &&\n        //       p.active\n        //     )\n        //     if (!oldProblem) {\n        //       // maybe already inactive or not present for this match - skip\n        //       continue\n        //     }\n        //     // mark the old row inactive\n        //     await prisma.problem.updateMany({\n        //       where: {\n        //         contestId: oldProblem.contestId,\n        //         index: oldProblem.index,\n        //         matchId: oldProblem.matchId,\n        //         active: true,\n        //       },\n        //       data: { active: false }\n        //     })\n        //     // Now request one replacement from /api/getProblems\n        //     // Build exclude: all currently-active + newly added\n        //     const excludeList = [...new Set(activeProblems)]\n        //     // Make POST to your getProblems endpoint (local)\n        //     try {\n        //       const resp = await fetch('http://localhost:3000/api/getProblems', {\n        //         method: 'POST',\n        //         headers: { 'Content-Type': 'application/json' },\n        //         body: JSON.stringify({\n        //           userHandles: allHandles,\n        //           minRating: match.minRating ?? undefined,\n        //           maxRating: match.maxRating ?? undefined,\n        //           count: 1,\n        //           exclude: excludeList,\n        //         }),\n        //       })\n        //       if (!resp.ok) {\n        //         console.warn('Replacement getProblems returned not ok', await resp.text())\n        //         // we won't crash  skip replacement for this cell\n        //         continue\n        //       }\n        //       const repData = await resp.json()\n        //       const repProblem = repData.problems?.[0]\n        //       if (!repProblem) {\n        //         // no replacement available  skip creating a new problem\n        //         continue\n        //       }\n        //       // create the new problem with same position and active = true\n        //       await prisma.problem.create({\n        //         data: {\n        //           contestId: repProblem.contestId,\n        //           index: repProblem.index,\n        //           matchId: match.id,\n        //           rating: repProblem.rating ?? 0,\n        //           name: repProblem.name ?? '',\n        //           position: oldProblem.position,\n        //           active: true,\n        //           maxPoints: repProblem.maxPoints ?? undefined, // if IOI\n        //         }\n        //       })\n        //       // add replacement key to activeProblems so later replacements in same run won't pick same\n        //       activeProblems.push(`${repProblem.contestId}-${repProblem.index}`)\n        //     } catch (err) {\n        //       console.error('Replacement failed for', solvedKey, err)\n        //       // continue processing other solves\n        //       continue\n        //     }\n        //   }\n        // } // end replace logic\n        }\n        // refetch match with updated solve logs\n        const updatedMatch = await _src_app_lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.match.findUnique({\n            where: {\n                id: matchId\n            },\n            include: {\n                problems: {\n                    where: {\n                        active: true\n                    },\n                    orderBy: {\n                        position: 'asc'\n                    }\n                },\n                teams: {\n                    include: {\n                        members: true\n                    }\n                },\n                solveLog: {\n                    include: {\n                        problem: true\n                    }\n                }\n            }\n        });\n        return res.status(200).json({\n            updated: true,\n            match: updatedMatch\n        });\n    } catch (err) {\n        console.error('Error in poll-submissions:', err);\n        return res.status(500).json({\n            error: 'Internal server error'\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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by1jcFxcYmluZ28tY3BcXGJpbmdvLWNwXFxwYWdlc1xcYXBpXFxwb2xsLXN1Ym1pc3Npb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnXG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tIFwiLi4vLi4vc3JjL2FwcC9saWIvcHJpc21hXCJcbmltcG9ydCB7IGNoZWNrU29sdmVzTG9naWMgfSBmcm9tICcuL2NoZWNrU29sdmVzTG9naWMnXG5pbXBvcnQgeyBjaGVja1NvbHZlc0xvZ2ljSU9JIH0gZnJvbSAnLi9jaGVja1NvbHZlc0xvZ2ljSU9JJ1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBsYWNlbWVudFByb2JsZW0oZXhjbHVkZTogc3RyaW5nW10sIG1pblJhdGluZz86IG51bWJlciwgbWF4UmF0aW5nPzogbnVtYmVyLCBoYW5kbGVzPzogc3RyaW5nW10gKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvZ2V0UHJvYmxlbXMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtaW5SYXRpbmc6IG1pblJhdGluZyA/PyA4MDAsXG4gICAgICAgIG1heFJhdGluZzogbWF4UmF0aW5nID8/IDM1MDAsXG4gICAgICAgIHVzZXJIYW5kbGVzOiBoYW5kbGVzLFxuICAgICAgICAvLyBvcHRpb25hbGx5IGluY2x1ZGUgZXhjbHVkZXMgaWYgeW91IGltcGxlbWVudCB0aGF0IG9uIGdldFByb2JsZW1zXG4gICAgICAgIC8vIGV4Y2x1ZGVQcm9ibGVtczogZXhjbHVkZSxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIGV4Y3VsZGU6IGV4Y2x1ZGVcbiAgICAgIH0pLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkRhYTogXCIsIGRhdGEpO1xuICAgIHJldHVybiAoZGF0YS5wcm9ibGVtcyAmJiBkYXRhLnByb2JsZW1zWzBdKSA/PyBudWxsO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdmZXRjaFJlcGxhY2VtZW50UHJvYmxlbSBlcnJvcicsIGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IGVycm9yOiAnTWV0aG9kIE5vdCBBbGxvd2VkJyB9KVxuICB9XG4gIC8vIGNvbnNvbGUubG9nKCdSZXF1ZXN0IGJvZHk6JywgcmVxLmJvZHkpO1xuXG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IG1hdGNoSWQgfSA9IHJlcS5ib2R5XG4gICAgaWYgKCFtYXRjaElkKSByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ21hdGNoSWQgcmVxdWlyZWQnIH0pXG4gICAgLy8gY29uc29sZS5sb2coJ1RIRSBJSUQ6JywgbWF0Y2hJZClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdUSEUgUkVBTCBTVFVGRjonLCByZXEuYm9keSlcbiAgICBjb25zdCBtYXRjaCA9IGF3YWl0IHByaXNtYS5tYXRjaC5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiBtYXRjaElkIH0sXG4gICAgICBpbmNsdWRlOiB7XG4gICAgICAgIHByb2JsZW1zOiB0cnVlLFxuICAgICAgICB0ZWFtczoge1xuICAgICAgICAgIGluY2x1ZGU6IHsgbWVtYmVyczogdHJ1ZSB9LFxuICAgICAgICB9LFxuICAgICAgICBzb2x2ZUxvZzoge2luY2x1ZGU6IHtwcm9ibGVtOiB0cnVlfX0sIC8vIG1heWJlIGNoYW5nZSB0byBlbnRpcmVseSB0cnVlIGxhdGVyXG4gICAgICB9LFxuICAgIH0pXG4gICAgXG4gICAgLy8gY29uc29sZS5sb2coJ0NyZWF0ZWQgbWF0Y2ggb2JqZWN0OicsIG1hdGNoKTtcbiAgICAvLyBjb25zb2xlLmxvZygnRE9ORTInKVxuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgZXJyb3I6ICdNYXRjaCBub3QgZm91bmQnIH0pXG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCdET05FMycpXG4gICAgY29uc29sZS5sb2coXCJNYXRjaCBQcm9ibGVtczogXCIsIG1hdGNoLnByb2JsZW1zKTtcblxuICAgIGNvbnN0IHByb2JsZW1zID0gbWF0Y2gucHJvYmxlbXNcbiAgICAuZmlsdGVyKHAgPT4gcC5hY3RpdmUgPT09IHRydWUpXG4gICAgLm1hcChwID0+ICh7XG4gICAgICBjb250ZXN0SWQ6IHAuY29udGVzdElkLFxuICAgICAgaW5kZXg6IHAuaW5kZXgsXG4gICAgfSkpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdUSEUgUkVBTCBTVFVGRjonLCBwcm9ibGVtcylcblxuICAgIGNvbnN0IHBsYXllcnMgPSBtYXRjaC50ZWFtcy5mbGF0TWFwKHRlYW0gPT5cbiAgICAgIHRlYW0ubWVtYmVycy5tYXAobWVtYmVyID0+ICh7XG4gICAgICAgIGhhbmRsZTogbWVtYmVyLmhhbmRsZSxcbiAgICAgICAgdGVhbTogdGVhbS5jb2xvcixcbiAgICAgIH0pKVxuICAgIClcbiAgICAvLyBjb21wdXRlIG1hdGNoIHdpbmRvdyB1c2VkIGJ5IElPSSBsb2dpY1xuICAgIGNvbnN0IG1hdGNoU3RhcnQgPSBuZXcgRGF0ZShtYXRjaC5zdGFydFRpbWUpO1xuICAgIGNvbnN0IG1hdGNoRW5kID0gbmV3IERhdGUobWF0Y2hTdGFydC5nZXRUaW1lKCkgKyBtYXRjaC5kdXJhdGlvbk1pbnV0ZXMgKiA2MDAwMCk7XG4gICAgLy8gY29uc29sZS5sb2coXCJXSEhISEhISEhISEhIQVRcIik7XG4gICAgaWYobWF0Y2gubW9kZSA9PT0gJ2lvaScpIHtcbiAgICAgIC8vIElPSSBtb2RlOiBnZXQgYmVzdCBzY29yZXMgcGVyIHByb2JsZW1cbiAgICAgIGNvbnNvbGUubG9nKFwiQUxJVkVcIik7XG4gICAgICBjb25zdCBjbGFpbXMgPSBhd2FpdCBjaGVja1NvbHZlc0xvZ2ljSU9JKHByb2JsZW1zLCBwbGF5ZXJzLG1hdGNoU3RhcnQudG9JU09TdHJpbmcoKSxtYXRjaEVuZC50b0lTT1N0cmluZygpKVxuICAgICAgLy8gY2xhaW1zOiB7ICcxMjM0LUEnOiB7IHRlYW0sIHNjb3JlLCB0aW1lc3RhbXAsIGhhbmRsZSB9IH1cbiAgICAgIGZvciAoY29uc3QgW2tleSwgY2xhaW1dIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltcykpIHtcbiAgICAgICAgIGNvbnN0IGRhc2ggPSBrZXkubGFzdEluZGV4T2YoJy0nKTtcbiAgICAgICAgY29uc3QgY29udGVzdElkU3RyID0ga2V5LnNsaWNlKDAsIGRhc2gpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGtleS5zbGljZShkYXNoICsgMSk7XG4gICAgICAgIGNvbnN0IGNvbnRlc3RJZE51bSA9IE51bWJlcihjb250ZXN0SWRTdHIpO1xuXG4gICAgICAgIC8vIGZpbmQgZXhpc3RpbmcgYnkgY29tcGFyaW5nIGFzIHN0cmluZ3MgdG8gYmUgcm9idXN0IChEQiBtYXkgc3RvcmUgbnVtZXJpYyBvciBzdHJpbmcgSURzKVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hdGNoLnNvbHZlTG9nLmZpbmQocyA9PiBTdHJpbmcocy5jb250ZXN0SWQpID09PSBjb250ZXN0SWRTdHIgJiYgcy5pbmRleCA9PT0gaW5kZXgpO1xuXG4gICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAvLyBjcmVhdGUgb25seSBpZiBzY29yZSA+IDBcbiAgICAgICAgICBpZiAoKGNsYWltLnNjb3JlID8/IDApID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnNvbHZlTG9nLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtYXRjaElkOiBtYXRjaC5pZCxcbiAgICAgICAgICAgICAgICBjb250ZXN0SWQ6IE51bWJlci5pc05hTihjb250ZXN0SWROdW0pID8gMCA6IGNvbnRlc3RJZE51bSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICB0ZWFtOiBjbGFpbS50ZWFtLFxuICAgICAgICAgICAgICAgIGhhbmRsZTogY2xhaW0uaGFuZGxlID8/ICcnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoY2xhaW0udGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICBzY29yZTogY2xhaW0uc2NvcmUgPz8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9sZFNjb3JlID0gZXhpc3Rpbmcuc2NvcmUgPz8gMFxuICAgICAgICAgIGlmICgoY2xhaW0uc2NvcmUgPz8gMCkgPiBvbGRTY29yZSkge1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnNvbHZlTG9nLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZy5pZCB9LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdGVhbTogY2xhaW0udGVhbSxcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGNsYWltLmhhbmRsZSA/PyBleGlzdGluZy5oYW5kbGUsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShjbGFpbS50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgIHNjb3JlOiBjbGFpbS5zY29yZSA/PyBleGlzdGluZy5zY29yZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSBpZiAoKGNsYWltLnNjb3JlID8/IDApID09PSBvbGRTY29yZSkge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWw6IGVhcmxpZXN0IHRpbWVzdGFtcCB0aWUtYnJlYWtcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZShjbGFpbS50aW1lc3RhbXApIDwgZXhpc3RpbmcudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByaXNtYS5zb2x2ZUxvZy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZy5pZCB9LFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgdGVhbTogY2xhaW0udGVhbSwgdGltZXN0YW1wOiBuZXcgRGF0ZShjbGFpbS50aW1lc3RhbXApLCBoYW5kbGU6IGNsYWltLmhhbmRsZSA/PyBleGlzdGluZy5oYW5kbGUgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnb2s/JylcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiUHJvYjo6IFwiLCBwcm9ibGVtcyk7XG4gICAgICBjb25zdCBjbGFpbXMgPSBhd2FpdCBjaGVja1NvbHZlc0xvZ2ljKHByb2JsZW1zLCBwbGF5ZXJzKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2kgZ3Vlc3M6ICcsIGNsYWltcylcbiAgICAgIC8vIFByZXBhcmUgbmV3IHNvbHZlcyB0byBhZGRcbiAgICAgIC8vIFByZXBhcmUgbmV3IHNvbHZlcyB0byBhZGQgKG9ubHkgdGhvc2Ugbm90IGFscmVhZHkgaW4gREIpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkM6IFwiLGNsYWltcyk7XG4gICAgICBjb25zdCBuZXdTb2x2ZXM6IEFycmF5PHtcbiAgICAgICAgaGFuZGxlOiBzdHJpbmc7XG4gICAgICAgIHRlYW06IHN0cmluZztcbiAgICAgICAgY29udGVzdElkOiBudW1iZXI7XG4gICAgICAgIGluZGV4OiBzdHJpbmc7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZTtcbiAgICAgICAgbWF0Y2hJZDogc3RyaW5nO1xuICAgICAgICBzY29yZT86IG51bWJlciB8IG51bGw7XG4gICAgICB9PiA9IFtdXG5cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdGVhbUNvbG9yXSBvZiBPYmplY3QuZW50cmllcyhjbGFpbXMpKSB7XG4gICAgICAgIGNvbnN0IFtjb250ZXN0SWRTdHIsIGluZGV4XSA9IGtleS5zcGxpdCgnLScpXG4gICAgICAgIGNvbnN0IGNvbnRlc3RJZCA9IE51bWJlcihjb250ZXN0SWRTdHIpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSByZWNvcmRlZFxuICAgICAgICBpZiAoIW1hdGNoLnNvbHZlTG9nLnNvbWUobG9nID0+IGxvZy5jb250ZXN0SWQgPT09IGNvbnRlc3RJZCAmJiBsb2cuaW5kZXggPT09IGluZGV4KSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpIHdhcyByaWdodCEhJylcbiAgICAgICAgICBuZXdTb2x2ZXMucHVzaCh7XG4gICAgICAgICAgICBoYW5kbGU6ICcnLCAvLyBvcHRpb25hbGx5IGZpbGwgbGF0ZXJcbiAgICAgICAgICAgIHRlYW06IHRlYW1Db2xvcixcbiAgICAgICAgICAgIGNvbnRlc3RJZCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbWF0Y2hJZDogbWF0Y2guaWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld1NvbHZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gbm90aGluZyBuZXdcbiAgICAgICAgLy8gcmV0dXJuIHVwZGF0ZWQ6ZmFsc2UgYnV0IGluY2x1ZGUgY2Fub25pY2FsIG1hdGNoIHNvIGNsaWVudCBjYW4gc3RheSBpbiBzeW5jXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRNYXRjaCA9IGF3YWl0IHByaXNtYS5tYXRjaC5maW5kVW5pcXVlKHtcbiAgICAgICAgICB3aGVyZTogeyBpZDogbWF0Y2hJZCB9LFxuICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgIHByb2JsZW1zOiB7IHdoZXJlOiB7IGFjdGl2ZTogdHJ1ZSB9LCBvcmRlckJ5OiB7IHBvc2l0aW9uOiAnYXNjJyB9IH0sXG4gICAgICAgICAgICB0ZWFtczogeyBpbmNsdWRlOiB7IG1lbWJlcnM6IHRydWUgfSB9LFxuICAgICAgICAgICAgc29sdmVMb2c6IHtpbmNsdWRlOiB7cHJvYmxlbTogdHJ1ZX19LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyB1cGRhdGVkOiBmYWxzZSwgbWF0Y2g6IHVwZGF0ZWRNYXRjaCB9KTtcbiAgICAgIH1cbiAgICAgICAvLyBGb3IgZWFjaCBuZXcgc29sdmU6IGNyZWF0ZSBzb2x2ZSBsb2cgYW5kIChpZiByZXBsYWNlIG1vZGUpIHJlcGxhY2UgdGhlIHByb2JsZW0gYXRvbWljYWxseVxuICAgICAgLy8gIGNvbnNvbGUubG9nKFwibmV3U29sdmVzOiBcIiwgbmV3U29sdmVzKTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBuZXdTb2x2ZXMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXN0SWQsIGluZGV4LCB0ZWFtIH0gPSBzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlICpvbGQqIHByb2JsZW0gcm93IChzaG91bGQgZXhpc3QpXG4gICAgICAgICAvLyBGaW5kIHRoZSAqYWN0aXZlKiBwcm9ibGVtIHJvdyB0aGF0IG1hdGNoZXMgdGhlIHNvbHZlZCBjb250ZXN0L2luZGV4XG4gICAgICAgIGNvbnN0IHNvbHZlZFJvdyA9IGF3YWl0IHByaXNtYS5wcm9ibGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgd2hlcmU6IHsgY29udGVzdElkLCBpbmRleCwgbWF0Y2hJZCwgYWN0aXZlOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgYW4gYWN0aXZlIHJvdyBmb3IgdGhpcyBjb250ZXN0L2luZGV4LCB0cnkgdGhlIHVuaXF1ZSBsb29rdXAgYXMgYSBmYWxsYmFja1xuICAgICAgICBjb25zdCBvbGRQcm9ibGVtID0gc29sdmVkUm93ID8/IGF3YWl0IHByaXNtYS5wcm9ibGVtLmZpbmRVbmlxdWUoe1xuICAgICAgICAgIHdoZXJlOiB7IGNvbnRlc3RJZF9pbmRleF9tYXRjaElkOiB7IGNvbnRlc3RJZCwgaW5kZXgsIG1hdGNoSWQgfSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3Qgb2xkUHJvYmxlbSA9IGF3YWl0IHByaXNtYS5wcm9ibGVtLmZpbmRVbmlxdWUoe1xuICAgICAgICAvLyAgIHdoZXJlOiB7IGNvbnRlc3RJZF9pbmRleF9tYXRjaElkOiB7IGNvbnRlc3RJZDogY29udGVzdElkLCBpbmRleDogaW5kZXgsIG1hdGNoSWQgfSB9LFxuICAgICAgICAvLyB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIHNvbHZlIGxvZyByZWZlcmVuY2luZyB0aGUgb2xkIHByb2JsZW0gKHNvIG1lc3NhZ2UgdXNlcyBvbGQgcHJvYmxlbSBmaWVsZHMpXG4gICAgICAgIGF3YWl0IHByaXNtYS5zb2x2ZUxvZy5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGhhbmRsZTogJycsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICB0ZWFtLFxuICAgICAgICAgICAgY29udGVzdElkLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBtYXRjaElkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHJlcGxhY2UgbW9kZSwgYXRvbWljYWxseSBkZWFjdGl2YXRlIG9sZCBwcm9ibGVtIGFuZCBjcmVhdGUgYSBuZXcgcmVwbGFjZW1lbnQgYXQgc2FtZSBwb3NpdGlvblxuICAgICAgICBpZiAobWF0Y2gubW9kZSA9PT0gJ3JlcGxhY2UnICYmIG9sZFByb2JsZW0pIHtcbiAgICAgICAgICAvLyBjb21wdXRlIHRhcmdldCByYXRpbmcgZm9yIHJlcGxhY2VtZW50XG4gICAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gbWF0Y2gucmVwbGFjZUluY3JlbWVudCA/PyAxMDA7XG4gICAgICAgICAgY29uc3QgbmV3UmF0aW5nVGFyZ2V0ID0gTWF0aC5taW4oMzUwMCwgKG9sZFByb2JsZW0ucmF0aW5nID8/IDApICsgaW5jcmVtZW50KTtcbiAgICAgICAgICBjb25zdCBhbGxIYW5kbGVzID0gbWF0Y2gudGVhbXMuZmxhdE1hcCgodGVhbSkgPT4gdGVhbS5tZW1iZXJzKS5mbGF0TWFwKChwKSA9PiBwLmhhbmRsZSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJJbmM6IFwiLCBpbmNyZW1lbnQpO1xuICAgICAgICAgIC8vIGZldGNoIGNhbmRpZGF0ZSByZXBsYWNlbWVudCBmcm9tIHlvdXIgcHJvYmxlbSBzb3VyY2UgKGdldFByb2JsZW1zKS4gV2UnbGwgYXNrIGZvciAxIHByb2JsZW0uXG4gICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRDYW5kaWRhdGUgPSBhd2FpdCBmZXRjaFJlcGxhY2VtZW50UHJvYmxlbShcbiAgICAgICAgICAgIHByb2JsZW1zLm1hcChwID0+IFN0cmluZyhwLmNvbnRlc3RJZCkgKyBwLmluZGV4KSwgLy8gb3B0aW9uYWwgZXhjbHVkZXNcbiAgICAgICAgICAgIG5ld1JhdGluZ1RhcmdldCwgLy8gdHJ5IHRvIGJpYXMgdG8gdGhlIGRlc2lyZWQgcmF0aW5nXG4gICAgICAgICAgICBuZXdSYXRpbmdUYXJnZXQsXG4gICAgICAgICAgICBhbGxIYW5kbGVzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSRVA6IFwiLCByZXBsYWNlbWVudENhbmRpZGF0ZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUHJvQkI6OiAnLCBwcm9ibGVtcyk7XG5cbiAgICAgICAgICAvLyBEbyBhdG9taWMgdHJhbnNhY3Rpb246IGRlYWN0aXZhdGUgb2xkIHByb2JsZW0gYW5kIGNyZWF0ZSBuZXcgb25lIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKGFzeW5jICh0eCkgPT4ge1xuICAgICAgICAgICAgLy8gbWFyayBvbGQgcHJvYmxlbSBpbmFjdGl2ZVxuICAgICAgICAgICAgYXdhaXQgdHgucHJvYmxlbS51cGRhdGUoe1xuICAgICAgICAgICAgICB3aGVyZTogeyBjb250ZXN0SWRfaW5kZXhfbWF0Y2hJZDogeyBjb250ZXN0SWQ6IG9sZFByb2JsZW0uY29udGVzdElkLCBpbmRleDogb2xkUHJvYmxlbS5pbmRleCwgbWF0Y2hJZCB9IH0sXG4gICAgICAgICAgICAgIGRhdGE6IHsgYWN0aXZlOiBmYWxzZSB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgcmVwbGFjZW1lbnQgY2FuZGlkYXRlLCBjcmVhdGUgaXQ7IG90aGVyd2lzZSBjcmVhdGUgYSBwbGFjZWhvbGRlciByb3cgKHlvdSBtYXkgdHdlYWspXG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRDYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgcmF0aW5nIHRvIG5ld1JhdGluZ1RhcmdldCB0byBhcHBseSBpbmNyZW1lbnQgcnVsZVxuICAgICAgICAgICAgICBhd2FpdCB0eC5wcm9ibGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgY29udGVzdElkOiByZXBsYWNlbWVudENhbmRpZGF0ZS5jb250ZXN0SWQgPz8gMCxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiByZXBsYWNlbWVudENhbmRpZGF0ZS5pbmRleCA/PyBTdHJpbmcoRGF0ZS5ub3coKSksXG4gICAgICAgICAgICAgICAgICBtYXRjaElkLFxuICAgICAgICAgICAgICAgICAgcmF0aW5nOiByZXBsYWNlbWVudENhbmRpZGF0ZT8ucmF0aW5nID8/IG5ld1JhdGluZ1RhcmdldCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHJlcGxhY2VtZW50Q2FuZGlkYXRlLm5hbWUgPz8gYFByb2JsZW0gJHtyZXBsYWNlbWVudENhbmRpZGF0ZS5pbmRleH1gLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG9sZFByb2JsZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmYWxsYmFjazogY3JlYXRlIGEgcGxhY2Vob2xkZXIgXCJ1bmtub3duXCIgcHJvYmxlbSB3aXRoIGNvbXB1dGVkIHJhdGluZ1xuICAgICAgICAgICAgICBhd2FpdCB0eC5wcm9ibGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgY29udGVzdElkOiAwLFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IFN0cmluZyhEYXRlLm5vdygpKSxcbiAgICAgICAgICAgICAgICAgIG1hdGNoSWQsXG4gICAgICAgICAgICAgICAgICByYXRpbmc6IG5ld1JhdGluZ1RhcmdldCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGBSZXBsYWNlbWVudCAoJHtuZXdSYXRpbmdUYXJnZXR9KWAsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogb2xkUHJvYmxlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAvLyBJbnNlcnQgbmV3IHNvbHZlcyBpZiBhbnlcbiAgICAgIC8vIGlmIChuZXdTb2x2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gICBhd2FpdCBwcmlzbWEuc29sdmVMb2cuY3JlYXRlTWFueSh7XG4gICAgICAvLyAgICAgZGF0YTogbmV3U29sdmVzLm1hcChucyA9PiAoe1xuICAgICAgLy8gICAgICAgaGFuZGxlOiBucy5oYW5kbGUsXG4gICAgICAvLyAgICAgICB0ZWFtOiBucy50ZWFtLFxuICAgICAgLy8gICAgICAgY29udGVzdElkOiBucy5jb250ZXN0SWQsXG4gICAgICAvLyAgICAgICBpbmRleDogbnMuaW5kZXgsXG4gICAgICAvLyAgICAgICB0aW1lc3RhbXA6IG5zLnRpbWVzdGFtcCxcbiAgICAgIC8vICAgICAgIG1hdGNoSWQ6IG5zLm1hdGNoSWQsXG4gICAgICAvLyAgICAgfSkpXG4gICAgICAvLyAgIH0pXG4gICAgICAgIFxuICAgICAgLy8gfVxuICAgICAgLy8gLy8gPT09PT09PSBSZXBsYWNlIGxvZ2ljIChpZiBtYXRjaC5tb2RlID09PSAncmVwbGFjZScpID09PT09PT1cbiAgICAgIC8vIGlmIChuZXdTb2x2ZXMubGVuZ3RoID4gMCAmJiBtYXRjaC5tb2RlID09PSAncmVwbGFjZScpIHtcbiAgICAgIC8vICAgLy8gUHJlcGFyZSBsaXN0IG9mIGFjdGl2ZSBwcm9ibGVtIGtleXMgdG8gZXhjbHVkZSBmcm9tIHJlcGxhY2VtZW50c1xuICAgICAgLy8gICAvLyBvbmx5IGluY2x1ZGUgY3VycmVudGx5IGFjdGl2ZSBwcm9ibGVtc1xuICAgICAgLy8gICBjb25zdCBhY3RpdmVQcm9ibGVtcyA9IG1hdGNoLnByb2JsZW1zXG4gICAgICAvLyAgICAgLmZpbHRlcihwID0+IHAuYWN0aXZlKVxuICAgICAgLy8gICAgIC5tYXAocCA9PiBgJHtwLmNvbnRlc3RJZH0tJHtwLmluZGV4fWApXG5cbiAgICAgIC8vICAgLy8gQWxzbyBhZGQgYW55IG5ld2x5LXNvbHZlZCBrZXlzIHNvIHJlcGxhY2VtZW50cyBhdm9pZCB0aGVtXG4gICAgICAvLyAgIGNvbnN0IG5ld2x5U29sdmVkS2V5cyA9IG5ld1NvbHZlcy5tYXAobnMgPT4gYCR7bnMuY29udGVzdElkfS0ke25zLmluZGV4fWApXG4gICAgICAvLyAgIGFjdGl2ZVByb2JsZW1zLnB1c2goLi4ubmV3bHlTb2x2ZWRLZXlzKVxuXG4gICAgICAvLyAgIC8vIEFsbCB1c2VyIGhhbmRsZXMgZm9yIGV4Y2x1ZGUgY2hlY2tzIChzYW1lIGFzIHdoZW4gY3JlYXRpbmcgdGhlIG1hdGNoKVxuICAgICAgLy8gICBjb25zdCBhbGxIYW5kbGVzID0gbWF0Y2gudGVhbXMuZmxhdE1hcCh0ID0+IHQubWVtYmVycy5tYXAobSA9PiBtLmhhbmRsZSkpXG5cbiAgICAgIC8vICAgLy8gV2UnbGwgaXRlcmF0ZSB0aHJvdWdoIG5ld1NvbHZlcyBzZXF1ZW50aWFsbHkuIEZvciBlYWNoIHNvbHZlZCBwcm9ibGVtOlxuICAgICAgLy8gICBmb3IgKGNvbnN0IHNvbHZlZCBvZiBuZXdTb2x2ZXMpIHtcbiAgICAgIC8vICAgICBjb25zdCBzb2x2ZWRLZXkgPSBgJHtzb2x2ZWQuY29udGVzdElkfS0ke3NvbHZlZC5pbmRleH1gXG5cbiAgICAgIC8vICAgICAvLyBmaW5kIHRoZSAqYWN0aXZlKiBQcm9ibGVtIHJvdyB0aGF0IG1hdGNoZXMgdGhpcyBjb250ZXN0SWQvaW5kZXggJiBtYXRjaElkXG4gICAgICAvLyAgICAgY29uc3Qgb2xkUHJvYmxlbSA9IG1hdGNoLnByb2JsZW1zLmZpbmQocCA9PlxuICAgICAgLy8gICAgICAgcC5jb250ZXN0SWQgPT09IHNvbHZlZC5jb250ZXN0SWQgJiZcbiAgICAgIC8vICAgICAgIHAuaW5kZXggPT09IHNvbHZlZC5pbmRleCAmJlxuICAgICAgLy8gICAgICAgcC5hY3RpdmVcbiAgICAgIC8vICAgICApXG5cbiAgICAgIC8vICAgICBpZiAoIW9sZFByb2JsZW0pIHtcbiAgICAgIC8vICAgICAgIC8vIG1heWJlIGFscmVhZHkgaW5hY3RpdmUgb3Igbm90IHByZXNlbnQgZm9yIHRoaXMgbWF0Y2ggLSBza2lwXG4gICAgICAvLyAgICAgICBjb250aW51ZVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgICAvLyBtYXJrIHRoZSBvbGQgcm93IGluYWN0aXZlXG4gICAgICAvLyAgICAgYXdhaXQgcHJpc21hLnByb2JsZW0udXBkYXRlTWFueSh7XG4gICAgICAvLyAgICAgICB3aGVyZToge1xuICAgICAgLy8gICAgICAgICBjb250ZXN0SWQ6IG9sZFByb2JsZW0uY29udGVzdElkLFxuICAgICAgLy8gICAgICAgICBpbmRleDogb2xkUHJvYmxlbS5pbmRleCxcbiAgICAgIC8vICAgICAgICAgbWF0Y2hJZDogb2xkUHJvYmxlbS5tYXRjaElkLFxuICAgICAgLy8gICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAvLyAgICAgICB9LFxuICAgICAgLy8gICAgICAgZGF0YTogeyBhY3RpdmU6IGZhbHNlIH1cbiAgICAgIC8vICAgICB9KVxuXG4gICAgICAvLyAgICAgLy8gTm93IHJlcXVlc3Qgb25lIHJlcGxhY2VtZW50IGZyb20gL2FwaS9nZXRQcm9ibGVtc1xuICAgICAgLy8gICAgIC8vIEJ1aWxkIGV4Y2x1ZGU6IGFsbCBjdXJyZW50bHktYWN0aXZlICsgbmV3bHkgYWRkZWRcbiAgICAgIC8vICAgICBjb25zdCBleGNsdWRlTGlzdCA9IFsuLi5uZXcgU2V0KGFjdGl2ZVByb2JsZW1zKV1cblxuICAgICAgLy8gICAgIC8vIE1ha2UgUE9TVCB0byB5b3VyIGdldFByb2JsZW1zIGVuZHBvaW50IChsb2NhbClcbiAgICAgIC8vICAgICB0cnkge1xuICAgICAgLy8gICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2dldFByb2JsZW1zJywge1xuICAgICAgLy8gICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIC8vICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAvLyAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIC8vICAgICAgICAgICB1c2VySGFuZGxlczogYWxsSGFuZGxlcyxcbiAgICAgIC8vICAgICAgICAgICBtaW5SYXRpbmc6IG1hdGNoLm1pblJhdGluZyA/PyB1bmRlZmluZWQsXG4gICAgICAvLyAgICAgICAgICAgbWF4UmF0aW5nOiBtYXRjaC5tYXhSYXRpbmcgPz8gdW5kZWZpbmVkLFxuICAgICAgLy8gICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgLy8gICAgICAgICAgIGV4Y2x1ZGU6IGV4Y2x1ZGVMaXN0LFxuICAgICAgLy8gICAgICAgICB9KSxcbiAgICAgIC8vICAgICAgIH0pXG5cbiAgICAgIC8vICAgICAgIGlmICghcmVzcC5vaykge1xuICAgICAgLy8gICAgICAgICBjb25zb2xlLndhcm4oJ1JlcGxhY2VtZW50IGdldFByb2JsZW1zIHJldHVybmVkIG5vdCBvaycsIGF3YWl0IHJlc3AudGV4dCgpKVxuICAgICAgLy8gICAgICAgICAvLyB3ZSB3b24ndCBjcmFzaCDigJQgc2tpcCByZXBsYWNlbWVudCBmb3IgdGhpcyBjZWxsXG4gICAgICAvLyAgICAgICAgIGNvbnRpbnVlXG4gICAgICAvLyAgICAgICB9XG5cbiAgICAgIC8vICAgICAgIGNvbnN0IHJlcERhdGEgPSBhd2FpdCByZXNwLmpzb24oKVxuICAgICAgLy8gICAgICAgY29uc3QgcmVwUHJvYmxlbSA9IHJlcERhdGEucHJvYmxlbXM/LlswXVxuXG4gICAgICAvLyAgICAgICBpZiAoIXJlcFByb2JsZW0pIHtcbiAgICAgIC8vICAgICAgICAgLy8gbm8gcmVwbGFjZW1lbnQgYXZhaWxhYmxlIOKAlCBza2lwIGNyZWF0aW5nIGEgbmV3IHByb2JsZW1cbiAgICAgIC8vICAgICAgICAgY29udGludWVcbiAgICAgIC8vICAgICAgIH1cblxuICAgICAgLy8gICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgcHJvYmxlbSB3aXRoIHNhbWUgcG9zaXRpb24gYW5kIGFjdGl2ZSA9IHRydWVcbiAgICAgIC8vICAgICAgIGF3YWl0IHByaXNtYS5wcm9ibGVtLmNyZWF0ZSh7XG4gICAgICAvLyAgICAgICAgIGRhdGE6IHtcbiAgICAgIC8vICAgICAgICAgICBjb250ZXN0SWQ6IHJlcFByb2JsZW0uY29udGVzdElkLFxuICAgICAgLy8gICAgICAgICAgIGluZGV4OiByZXBQcm9ibGVtLmluZGV4LFxuICAgICAgLy8gICAgICAgICAgIG1hdGNoSWQ6IG1hdGNoLmlkLFxuICAgICAgLy8gICAgICAgICAgIHJhdGluZzogcmVwUHJvYmxlbS5yYXRpbmcgPz8gMCxcbiAgICAgIC8vICAgICAgICAgICBuYW1lOiByZXBQcm9ibGVtLm5hbWUgPz8gJycsXG4gICAgICAvLyAgICAgICAgICAgcG9zaXRpb246IG9sZFByb2JsZW0ucG9zaXRpb24sXG4gICAgICAvLyAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgLy8gICAgICAgICAgIG1heFBvaW50czogcmVwUHJvYmxlbS5tYXhQb2ludHMgPz8gdW5kZWZpbmVkLCAvLyBpZiBJT0lcbiAgICAgIC8vICAgICAgICAgfVxuICAgICAgLy8gICAgICAgfSlcblxuICAgICAgLy8gICAgICAgLy8gYWRkIHJlcGxhY2VtZW50IGtleSB0byBhY3RpdmVQcm9ibGVtcyBzbyBsYXRlciByZXBsYWNlbWVudHMgaW4gc2FtZSBydW4gd29uJ3QgcGljayBzYW1lXG4gICAgICAvLyAgICAgICBhY3RpdmVQcm9ibGVtcy5wdXNoKGAke3JlcFByb2JsZW0uY29udGVzdElkfS0ke3JlcFByb2JsZW0uaW5kZXh9YClcbiAgICAgIC8vICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlcGxhY2VtZW50IGZhaWxlZCBmb3InLCBzb2x2ZWRLZXksIGVycilcbiAgICAgIC8vICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgb3RoZXIgc29sdmVzXG4gICAgICAvLyAgICAgICBjb250aW51ZVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSAvLyBlbmQgcmVwbGFjZSBsb2dpY1xuICAgIH1cbiAgICAvLyByZWZldGNoIG1hdGNoIHdpdGggdXBkYXRlZCBzb2x2ZSBsb2dzXG4gICAgY29uc3QgdXBkYXRlZE1hdGNoID0gYXdhaXQgcHJpc21hLm1hdGNoLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHsgaWQ6IG1hdGNoSWQgfSxcbiAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgcHJvYmxlbXM6IHt3aGVyZToge2FjdGl2ZTogdHJ1ZX0sIG9yZGVyQnk6IHtwb3NpdGlvbjogJ2FzYyd9fSxcbiAgICAgICAgdGVhbXM6IHsgaW5jbHVkZTogeyBtZW1iZXJzOiB0cnVlIH0gfSxcbiAgICAgICAgc29sdmVMb2c6IHtpbmNsdWRlOiB7cHJvYmxlbTogdHJ1ZX19LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyB1cGRhdGVkOiB0cnVlLCBtYXRjaDogdXBkYXRlZE1hdGNoIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwb2xsLXN1Ym1pc3Npb25zOicsIGVycilcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbInByaXNtYSIsImNoZWNrU29sdmVzTG9naWMiLCJjaGVja1NvbHZlc0xvZ2ljSU9JIiwiZmV0Y2hSZXBsYWNlbWVudFByb2JsZW0iLCJleGNsdWRlIiwibWluUmF0aW5nIiwibWF4UmF0aW5nIiwiaGFuZGxlcyIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidXNlckhhbmRsZXMiLCJjb3VudCIsImV4Y3VsZGUiLCJvayIsImRhdGEiLCJqc29uIiwicHJvYmxlbXMiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJoYW5kbGVyIiwicmVxIiwic3RhdHVzIiwibWF0Y2hJZCIsIm1hdGNoIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwiaWQiLCJpbmNsdWRlIiwidGVhbXMiLCJtZW1iZXJzIiwic29sdmVMb2ciLCJwcm9ibGVtIiwibG9nIiwiZmlsdGVyIiwicCIsImFjdGl2ZSIsIm1hcCIsImNvbnRlc3RJZCIsImluZGV4IiwicGxheWVycyIsImZsYXRNYXAiLCJ0ZWFtIiwibWVtYmVyIiwiaGFuZGxlIiwiY29sb3IiLCJtYXRjaFN0YXJ0IiwiRGF0ZSIsInN0YXJ0VGltZSIsIm1hdGNoRW5kIiwiZ2V0VGltZSIsImR1cmF0aW9uTWludXRlcyIsIm1vZGUiLCJjbGFpbXMiLCJ0b0lTT1N0cmluZyIsImtleSIsImNsYWltIiwiT2JqZWN0IiwiZW50cmllcyIsImRhc2giLCJsYXN0SW5kZXhPZiIsImNvbnRlc3RJZFN0ciIsInNsaWNlIiwiY29udGVzdElkTnVtIiwiTnVtYmVyIiwiZXhpc3RpbmciLCJmaW5kIiwicyIsIlN0cmluZyIsInNjb3JlIiwiY3JlYXRlIiwiaXNOYU4iLCJ0aW1lc3RhbXAiLCJ1bmRlZmluZWQiLCJvbGRTY29yZSIsInVwZGF0ZSIsIm5ld1NvbHZlcyIsInRlYW1Db2xvciIsInNwbGl0Iiwic29tZSIsInB1c2giLCJsZW5ndGgiLCJ1cGRhdGVkTWF0Y2giLCJvcmRlckJ5IiwicG9zaXRpb24iLCJ1cGRhdGVkIiwic29sdmVkUm93IiwiZmluZEZpcnN0Iiwib2xkUHJvYmxlbSIsImNvbnRlc3RJZF9pbmRleF9tYXRjaElkIiwiaW5jcmVtZW50IiwicmVwbGFjZUluY3JlbWVudCIsIm5ld1JhdGluZ1RhcmdldCIsIk1hdGgiLCJtaW4iLCJyYXRpbmciLCJhbGxIYW5kbGVzIiwicmVwbGFjZW1lbnRDYW5kaWRhdGUiLCIkdHJhbnNhY3Rpb24iLCJ0eCIsIm5vdyIsIm5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/poll-submissions.ts\n");

/***/ }),

/***/ "(api-node)/./src/app/lib/prisma.ts":
/*!*******************************!*\
  !*** ./src/app/lib/prisma.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prisma: () => (/* binding */ prisma)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n// src/app/lib/prisma.ts (or wherever your lib folder is)\n\nconst globalForPrisma = globalThis;\nconst prisma = globalForPrisma.prisma ?? new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log: [\n        'query'\n    ]\n});\nif (true) globalForPrisma.prisma = prisma;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3NyYy9hcHAvbGliL3ByaXNtYS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx5REFBeUQ7QUFDWDtBQUU5QyxNQUFNQyxrQkFBa0JDO0FBSWpCLE1BQU1DLFNBQ1hGLGdCQUFnQkUsTUFBTSxJQUN0QixJQUFJSCx3REFBWUEsQ0FBQztJQUNmSSxLQUFLO1FBQUM7S0FBUTtBQUNoQixHQUFHO0FBRUwsSUFBSUMsSUFBcUMsRUFBRUosZ0JBQWdCRSxNQUFNLEdBQUdBIiwic291cmNlcyI6WyJEOlxcYmluZ28tY3BcXGJpbmdvLWNwXFxiaW5nby1jcFxcc3JjXFxhcHBcXGxpYlxccHJpc21hLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hcHAvbGliL3ByaXNtYS50cyAob3Igd2hlcmV2ZXIgeW91ciBsaWIgZm9sZGVyIGlzKVxuaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xuXG5jb25zdCBnbG9iYWxGb3JQcmlzbWEgPSBnbG9iYWxUaGlzIGFzIHVua25vd24gYXMge1xuICBwcmlzbWE6IFByaXNtYUNsaWVudCB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBwcmlzbWEgPVxuICBnbG9iYWxGb3JQcmlzbWEucHJpc21hID8/XG4gIG5ldyBQcmlzbWFDbGllbnQoe1xuICAgIGxvZzogWydxdWVyeSddLFxuICB9KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIGdsb2JhbEZvclByaXNtYS5wcmlzbWEgPSBwcmlzbWE7XG4iXSwibmFtZXMiOlsiUHJpc21hQ2xpZW50IiwiZ2xvYmFsRm9yUHJpc21hIiwiZ2xvYmFsVGhpcyIsInByaXNtYSIsImxvZyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./src/app/lib/prisma.ts\n");

/***/ }),

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fpoll-submissions&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cpoll-submissions.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();